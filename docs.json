[{"name":"Bytes.Comparable","comment":" Comparable Bytes\n\n-- TODO: Because we rely on the sorting of the hex string,\n-- it is super important to check that we only use\n-- lower case letters, but no uppercase.\n\n@docs Bytes\n@docs Any, toAny\n@docs chunksOf, width, isEmpty\n@docs fromBytes, fromHex, fromHexUnchecked, fromText, fromU8\n@docs toBytes, toHex, toText, toCbor, toU8\n\n","unions":[{"name":"Any","comment":" A catch-all phantom type for bytes.\n","args":[],"cases":[]},{"name":"Bytes","comment":" A custom `Bytes` type that is comparable with `==`.\n\nUseful as otherwise, the original `Bytes` type from `elm/bytes` package cannot be used to compare for equality with `==`.\nThe phantom type parameter `a` indicates what type of Bytes are stored.\n\n","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"chunksOf","comment":" Break a Bytestring into a list of chunks. Chunks are of the given width,\nexcept the last chunk which is only _at most_ the given width.\n","type":"Basics.Int -> Bytes.Comparable.Bytes a -> List.List (Bytes.Comparable.Bytes a)"},{"name":"fromBytes","comment":" Create a [Bytes] object from an elm/bytes [Bytes.Bytes].\n","type":"Bytes.Bytes -> Bytes.Comparable.Bytes a"},{"name":"fromHex","comment":" Create a [Bytes] object from a hex-encoded string.\n","type":"String.String -> Maybe.Maybe (Bytes.Comparable.Bytes a)"},{"name":"fromHexUnchecked","comment":" Same as [fromHex] except it does not check that the hex-encoded string is well formed.\nIt is your responsability.\n","type":"String.String -> Bytes.Comparable.Bytes a"},{"name":"fromText","comment":" Create a [Bytes] with some text encoded as UTF8.\n","type":"String.String -> Bytes.Comparable.Bytes a"},{"name":"fromU8","comment":" Create a [Bytes] object from individual U8 integers.\n","type":"List.List Basics.Int -> Bytes.Comparable.Bytes a"},{"name":"isEmpty","comment":" Check if this is empy.\n","type":"Bytes.Comparable.Bytes a -> Basics.Bool"},{"name":"toAny","comment":" Convert any type of bytes to `Bytes Any`.\n","type":"Bytes.Comparable.Bytes a -> Bytes.Comparable.Bytes Bytes.Comparable.Any"},{"name":"toBytes","comment":" Convert [Bytes] into elm/bytes [Bytes.Bytes].\n","type":"Bytes.Comparable.Bytes a -> Bytes.Bytes"},{"name":"toCbor","comment":" Cbor encoder.\n","type":"Bytes.Comparable.Bytes a -> Cbor.Encode.Encoder"},{"name":"toHex","comment":" Convert [Bytes] into a hex-encoded String.\n","type":"Bytes.Comparable.Bytes a -> String.String"},{"name":"toText","comment":" Convert [Bytes] into a UTF8 String.\n","type":"Bytes.Comparable.Bytes a -> Maybe.Maybe String.String"},{"name":"toU8","comment":" Convert a given [Bytes] into a list of U8 integers.\n","type":"Bytes.Comparable.Bytes a -> List.List Basics.Int"},{"name":"width","comment":" Length in bytes.\n","type":"Bytes.Comparable.Bytes a -> Basics.Int"}],"binops":[]},{"name":"Bytes.Crc8","comment":" CRC-8 digests\n\n@docs Crc8, digest\n\n","unions":[{"name":"Crc8","comment":" Phantom type for a 1-byte CRC8 checksum.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"digest","comment":" Function for finding the CRC-8 digest of a given [`Bytes`].\n\nTaken from [Haskell's `crc` library](https://hackage.haskell.org/package/crc-0.1.1.1/docs/src/Data.Digest.CRC8.html#updateDigest8), this\nimplementation uses the table lookup optimizatino for finding the digest.\n\n","type":"Bytes.Comparable.Bytes a -> Bytes.Comparable.Bytes Bytes.Crc8.Crc8"}],"binops":[]},{"name":"Bytes.Map","comment":" A `BytesMap` is a dictionnary mapping unique keys to values, where all keys are\nbyte strings.\n\nInsert, remove, and query operations all take O(log n) time.\n\n\n## BytesMaps\n\n@docs BytesMap\n\n\n## Build\n\n@docs empty, singleton, insert, update, remove\n\n\n## Query\n\n@docs isEmpty, member, get, size\n\n\n## Lists\n\n@docs keys, values, toList, fromList\n\n\n## Transform\n\n@docs map, mapWithKeys, foldl, foldlWithKeys, foldr, foldrWithKeys, filter, filterWithKeys\n\n\n## Combine\n\n@docs union, intersect, diff, merge\n\n\n## Encode / Decode\n\n@docs toCbor, fromCbor\n\n","unions":[{"name":"BytesMap","comment":" Dictionary mapping [Bytes] keys to values.\n","args":["k","v"],"cases":[]}],"aliases":[],"values":[{"name":"diff","comment":" Keep a key-value pair when its key does not appear in the second `BytesMap`.\n","type":"Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"empty","comment":" Create an empty `BytesMap`.\n","type":"Bytes.Map.BytesMap k v"},{"name":"filter","comment":" Keep only the values that pass the given test.\n","type":"(v -> Basics.Bool) -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"filterWithKeys","comment":" Keep only the key-value pairs that pass the given test.\n","type":"(Bytes.Comparable.Bytes k -> v -> Basics.Bool) -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"foldl","comment":" Fold over the values in a `BytesMap` from lowest key to highest key.\n","type":"(v -> result -> result) -> result -> Bytes.Map.BytesMap k v -> result"},{"name":"foldlWithKeys","comment":" Fold over the key-value pairs in a `BytesMap` from lowest key to highest key.\n","type":"(Bytes.Comparable.Bytes k -> v -> result -> result) -> result -> Bytes.Map.BytesMap k v -> result"},{"name":"foldr","comment":" Fold over the values in a `BytesMap` from highest key to lowest key.\n","type":"(v -> result -> result) -> result -> Bytes.Map.BytesMap k v -> result"},{"name":"foldrWithKeys","comment":" Fold over the key-value pairs in a `BytesMap` from highest key to lowest key.\n","type":"(Bytes.Comparable.Bytes k -> v -> result -> result) -> result -> Bytes.Map.BytesMap k v -> result"},{"name":"fromCbor","comment":" CBOR decoder.\n","type":"Cbor.Decode.Decoder v -> Cbor.Decode.Decoder (Bytes.Map.BytesMap k v)"},{"name":"fromList","comment":" Convert an association list into a `BytesMap`.\n","type":"List.List ( Bytes.Comparable.Bytes k, v ) -> Bytes.Map.BytesMap k v"},{"name":"get","comment":" Get the value associated with a key. If the key is not found, return `Nothing`. This is useful when you are not sure if a key will be in the `BytesMap`\n","type":"Bytes.Comparable.Bytes k -> Bytes.Map.BytesMap k v -> Maybe.Maybe v"},{"name":"insert","comment":" Insert a key-value pair into a `BytesMap`. Replaces value when there is a collision.\n","type":"Bytes.Comparable.Bytes k -> v -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"intersect","comment":" Keep a key-value pair when its key appears in the second `BytesMap`.\nPreference is given to values in the first `BytesMap`.\n","type":"Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"isEmpty","comment":" Determine if a `BytesMap` is empty.\n","type":"Bytes.Map.BytesMap k v -> Basics.Bool"},{"name":"keys","comment":" Get all of the keys in a `BytesMap`, sorted from lowest to highest.\n","type":"Bytes.Map.BytesMap k v -> List.List (Bytes.Comparable.Bytes k)"},{"name":"map","comment":" Apply a function to all values in a `BytesMap`.\n","type":"(a -> b) -> Bytes.Map.BytesMap k a -> Bytes.Map.BytesMap k b"},{"name":"mapWithKeys","comment":" Apply a function to all keys and values in a `BytesMap`.\n","type":"(Bytes.Comparable.Bytes k -> a -> b) -> Bytes.Map.BytesMap k a -> Bytes.Map.BytesMap k b"},{"name":"member","comment":" Determine if a key is in a `BytesMap`.\n","type":"Bytes.Comparable.Bytes k -> Bytes.Map.BytesMap k v -> Basics.Bool"},{"name":"merge","comment":" The most general way of combining two `BytesMap`. You provide three accumulators for when a given key appears:\n\n  - Only in the left `BytesMap`.\n  - In both `BytesMap`.\n  - Only in the right `BytesMap`.\n\nYou then traverse all the keys from lowest to highest, building up whatever you want.\n\n","type":"(Bytes.Comparable.Bytes k -> a -> result -> result) -> (Bytes.Comparable.Bytes k -> a -> b -> result -> result) -> (Bytes.Comparable.Bytes k -> b -> result -> result) -> Bytes.Map.BytesMap k a -> Bytes.Map.BytesMap k b -> result -> result"},{"name":"remove","comment":" Remove a key-value pair from a `BytesMap`. If the key is not found, no changes\nare made.\n","type":"Bytes.Comparable.Bytes k -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"singleton","comment":" Create a `BytesMap` with one key-value pair.\n","type":"Bytes.Comparable.Bytes k -> v -> Bytes.Map.BytesMap k v"},{"name":"size","comment":" Determine the number of key-value pairs in the `BytesMap`.\n","type":"Bytes.Map.BytesMap k v -> Basics.Int"},{"name":"toCbor","comment":" Cbor encoder.\n","type":"(v -> Cbor.Encode.Encoder) -> Bytes.Map.BytesMap k v -> Cbor.Encode.Encoder"},{"name":"toList","comment":" Convert a `BytesMap` into an association list of key-value pairs, sorted by keys.\n","type":"Bytes.Map.BytesMap k v -> List.List ( Bytes.Comparable.Bytes k, v )"},{"name":"union","comment":" Combine two `BytesMap`. If there is a collision, preference is given to\nthe first `BytesMap`.\n","type":"Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"update","comment":" Update the value of a `BytesMap` for a specific key with a given function.\n","type":"Bytes.Comparable.Bytes k -> (Maybe.Maybe v -> Maybe.Maybe v) -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"values","comment":" Get all of the values in a dictionary, in the order of their keys.\n","type":"Bytes.Map.BytesMap k v -> List.List v"}],"binops":[]},{"name":"Cardano","comment":" Cardano stuff\n\n\n# Transaction Building Overview\n\nThis framework aims to provide intuitive and correct building blocks\nfor transaction building, based on the following aspects of transactions.\n\n1.  Intent: what we want to achieve with this transaction\n      - Transfer: send some tokens from somewhere to somewhere else\n      - Mint and burn: create and destroy tokens\n      - Use a script: provide/spend tokens and data to/from a script\n      - Stake management: collect rewards, manage delegations and pool registrations\n      - Voting: vote on proposals\n      - Propose: make your own proposals\n2.  Metadata: additional information\n3.  Constraints: what additional constraints do we want to set\n      - Temporal validity range: first/last slots when the Tx is valid\n4.  Requirements: what is imposed by the protocol\n      - Tx fee: depends on size/mem/cpu\n      - Hashes: for metadata and script data\n      - Collateral: for plutus scripts\n      - Signatures: for consuming inputs and scripts requirements\n\nThis API revolves around composing intents, then adding metadata and constraints,\nand finally trying to validate it and auto-populate all requirements.\nThat’s enough theory, let’s get more concrete.\n\nLet’s first define some addresses we are going to be using.\n\n    addressFromHex addressHexString =\n        Cardano.Address.fromBytes addressHexString\n            |> Maybe.withDefault shouldNotErrorIfIsACorrectAddress\n\n    ( me, you, someone ) =\n        ( addressFromHex \"01...\"\n        , addressFromHex \"01...\"\n        , addressFromHex \"01...\"\n        )\n\nHere is a simple way to send 1 Ada to someone else.\n\n    -- 1 Ada is 1000000 Lovelaces\n    -- Asset amounts are typed with unbounded Natural numbers\n    oneAda =\n        Value.onlyLovelace (Natural.fromSafeString \"1000000\")\n\n    -- We need to provide available UTxOs for Tx finalization.\n    -- For this simple Tx, it only needs to know of our own UTxOs,\n    -- that we would typically retrieve via an API provider.\n    localStateUtxos =\n        Utxo.refDictFromList myUtxos\n\n    sendOneAdaToSomeoneTx =\n        [ Spend (FromWallet me oneAda), SendTo someone oneAda ]\n            |> finalize localStateUtxos []\n\nThe finalization step validates the Tx, compute the fees and add other required fields.\n\nMore control on the transfer is possible if we want to have multiple senders and receivers.\nHere is an example where me and you both contribute 1 Ada.\n\n    twoAda =\n        Value.add oneAda oneAda\n\n    localStateUtxos =\n        Utxo.refDictFromList (myUtxos ++ yourUtxos)\n\n    bothSendOneAdaToSomeoneTx =\n        [ Spend (FromWallet me oneAda)\n        , Spend (FromWallet you oneAda)\n        , SendTo someone twoAda\n        ]\n            |> finalize localStateUtxos []\n\nTo mint or burn via a native script, here is what we can do.\n\n    ( dogScriptRef, dogPolicyId, dogAssetName ) =\n        Debug.todo \"dog info is provided\"\n\n    ( catScriptRef, catPolicyId, catAssetName ) =\n        Debug.todo \"cat info is provided\"\n\n    localStateUtxos =\n        Utxo.refDictFromList (myUtxos ++ scriptsRefsUtxos)\n\n    mintAndBurnTx =\n        -- minting 1 dog\n        -- Mint amounts are of type Integer: unbounded positive or negative integers\n        [ MintBurn\n            { policyId = dogPolicyId\n            , assets = Map.singleton dogAssetName Integer.one\n            , scriptWitness = NativeWitness (WitnessReference dogScriptRef)\n            }\n        , SendTo me (Value.onlyToken dogPolicyId dogAssetName Natural.one)\n\n        -- burning 1 cat\n        , Spend <| FromWallet me (Value.onlyToken catPolicyId catAssetName Natural.one)\n        , MintBurn\n            { policyId = catPolicyId\n            , assets = Map.singleton catAssetName Integer.negativeOne\n            , scriptWitness = NativeWitness (WitnessReference catScriptRef)\n            }\n        ]\n            |> finalize localStateUtxos []\n\nLet’s show how to use a native script to lock some tokens,\nthat can only be retrieved with our signature.\n\n    -- Retrieve my public key credential from my address\n    myKeyCred =\n        Address.extractPubKeyHash me\n            |> Maybe.withDefault dummyCredential\n\n    -- Native script to lock funds with our public key\n    lockScript =\n        ScriptPubkey myKeyCred\n\n    lockScriptHash =\n        -- TODO: Script.hash\n        Script.hash (Script.Native lockScript)\n\n    -- Deriving the script address from the script hash\n    scriptAddress =\n        Address.Shelley\n            { networkId = Mainnet\n            , paymentCredential = ScriptHash lockScriptHash\n\n            -- Adding our stake credential while we are at it\n            -- so that our ada stays staked and yields staking rewards\n            , stakeCredential = Address.extractStakeCredential me\n            }\n\n    localStateUtxos =\n        Utxo.refDictFromList myUtxos\n\n    nativeLockTx =\n        [ Spend (FromWallet me twoAda), SendTo scriptAddress twoAda ]\n            |> finalize localStateUtxos []\n\nAs you can see, we could even keep our stake credential\nwhile locking our ada into the script address.\nIt means the locked ada will still be counted in our stake for the rewards.\nThis is thanks to Cardano addresses which have two parts.\nThe script logic only determines the first part of the address.\n\nLet’s show an example how to spend utxos from this native script.\nWe want to retrieve 1 ada from it, and keep the other ada locked.\nWe need to do that in two actions.\n\n1.  Spend the whole UTxO, with its 2 ada in it.\n2.  Send 1 ada back to the same address.\n\nWe cannot partially spend UTxOs.\nUTxOs are like bills, you spend them whole and get change for overspending.\n\n    ( lockedUtxoRef, lockedOutput ) =\n        -- TODO: Transaction.findOutputUtxosAt\n        Transaction.findOutputUtxosAt scriptAddress nativeLockTx\n            |> List.head\n\n    { updatedState } =\n        Cardano.updateLocalState txId nativeLockTx localStateUtxos\n\n    nativeUnlockTx =\n        [ Spend <|\n            FromNativeScript\n                -- spend the whole UTxO\n                { spentInput = lockedUtxoRef\n\n                -- This native script is so small,\n                -- the easiest way to provide it is directly by value instead of by reference\n                , nativeScriptWitness = WitnessValue lockScript\n                }\n\n        -- Retrieve 1 ada and send 1 ada back to the contract\n        , SendTo me oneAda\n        , SendTo scriptAddress oneAda\n        ]\n            |> finalize updatedState []\n\nAlright, how about doing all those things with Plutus scripts now?\nPlutus scripts can be used for many purposes such as minting,\nspending funds or withdrawing staking rewards.\n\nAll script executions need to provide a \"redeemer\".\nThis is some mandatory piece of data provided as argument to the script function.\nTransaction signatures required by the script must also be specified in a dedicated field.\nThis enables very efficient script executions since they can just check\nthat a public key is present in that `requiredSigners` field.\n\nLet’s start with a simple minting and burning example.\nFor this example, we suppose the Plutus script was already written,\nin some onchain language, like [Aiken](https://aiken-lang.org/).\nThis Plutus script will accept any mint or burn\nas long as we present our signature in the transaction.\nThe redeemer is not used at all so we can define a dummy one,\nof the smallest size possible since a redeemer is mandatory.\n\n    ( dogScriptOutputRef, dogPolicyId, dogAssetName ) =\n        Debug.todo \"dog info is provided\"\n\n    ( catScriptOutputRef, catPolicyId, catAssetName ) =\n        Debug.todo \"cat info is provided\"\n\n    myKeyCred =\n        Address.extractPubKeyHash me\n            |> Maybe.withDefault dummyCredential\n\n    -- Dummy redeemer of the smallest size possible.\n    -- A redeemer is mandatory, but unchecked by this contract anyway.\n    dummyRedeemer =\n        Data.Int Integer.zero\n\n    localStateUtxos =\n        Utxo.refDictFromList (myUtxos ++ scriptsRefsUtxos)\n\n    mintAndBurnTx =\n        -- minting 1 dog\n        [ MintBurn\n            { policyId = dogPolicyId\n            , assets = Map.singleton dogAssetName Integer.one\n            , scriptWitness =\n                PlutusWitness\n                    { script = WitnessReference dogScriptOutputRef\n                    , redeemerData = \\_ -> dummyRedeemer\n                    , requiredSigners = [ myKeyCred ]\n                    }\n            }\n        , SendTo me (Value.onlyToken dogPolicyId dogAssetName Natural.one)\n\n        -- burning 1 cat\n        , Spend <| FromWallet me (Value.onlyToken catPolicyId catAssetName Natural.one)\n        , MintBurn\n            { policyId = catPolicyId\n            , assets = Map.singleton catAssetName Integer.negativeOne\n            , scriptWitness =\n                PlutusWitness\n                    { script = WitnessReference catScriptOutputRef\n                    , redeemerData = \\_ -> dummyRedeemer\n                    , requiredSigners = [ myKeyCred ]\n                    }\n            }\n        ]\n            |> finalize localStateUtxos []\n\nYou may have noticed that `redeemerData` is taking a function instead of just a redeemer.\nThis is to enable more advanced use cases such as [UTxO indexers][utxo-indexers].\nBut for simple use cases, we can just ignore that argument with an underscore `_`.\n\n[utxo-indexers]: https://github.com/Anastasia-Labs/aiken-design-patterns\n\nOk now let’s show how sending to a Plutus script would be done.\nAs before, we’ll use the simple example of a lock script.\nBut this time, we don’t write it directly (as in the NativeScript example).\nInstead we suppose the script was written in some onchain language (Aiken, Opshin, Plutus Tx, ...),\nand the blueprint of the script is available, with its hash.\n\nIn the eUTxO model, UTxOs sent to a script address must have a piece of data attached.\nThat piece of data is referred to as the \"datum\".\nIt will be passed as argument to the script execution\nwhen some future transaction try to spend that UTxO later.\n\n    lockScriptHash =\n        extractedFromBlueprint\n\n    -- A script address is directly tied to the script hash\n    -- and so indirectly also tied to the (immutable) script code.\n    scriptAddress =\n        Address.Shelley\n            { networkId = Mainnet\n            , paymentCredential = ScriptHash lockScriptHash\n            , stakeCredential = Address.extractStakeCredential me\n            }\n\n    myKeyCred =\n        Address.extractPubKeyHash me\n            |> Maybe.withDefault dummyCredential\n\n    -- Put the unlocking pubkey hash in the datum of the funds we lock\n    datumWithKeyCred =\n        Data.Bytes (Bytes.toAny myKeyCred)\n\n    localStateUtxos =\n        Utxo.refDictFromList (myUtxos ++ scriptsRefsUtxos)\n\n    lockInPlutusScriptTx =\n        [ Spend (FromWallet me fourAda)\n        , SendToOutput\n            { address = scriptAddress\n            , amount = fourAda\n            , datumOption = Just (Datum datumWithKeyCred)\n            , referenceScript = Nothing\n            }\n        ]\n            |> finalize localStateUtxos []\n\nNow that we know how to send values to a script, let’s see how to collect them.\nWe will show how to retrieve 2 ada from the previously locked 4 ada.\nFor that, we need to do a few things:\n\n1.  Spend the whole UTxO, with its 4 ada in it.\n    We cannot partially spend UTxOs.\n    UTxOs are like bills, you spend them whole and get change for overspending.\n2.  Provide the script code to the transaction.\n    The script hash must match with the first part of the UTxO address we are spending.\n3.  Provide our signature for the proof that the script needs.\n4.  Retrieve 2 ada from that spent UTxO, and send 2 ada back to the same script.\n\nFor such a tiny script, which just checks if our signature is present,\nno need to put it in a reference UTxO first.\nWe can embed it directly in the transaction witness.\n\n    ( lockedUtxoRef, lockedOutput ) =\n        -- TODO: Transaction.findOutputUtxosAt\n        Transaction.findOutputUtxosAt scriptAddress lockInPlutusScriptTx\n            |> List.head\n\n    { updatedState } =\n        Cardano.updateLocalState txId lockInPlutusScriptTx localStateUtxos\n\n    lockScript =\n        extractedFromTheBlueprint\n\n    unlockFromPlutusScriptTx =\n        -- Collect the locked UTxO at the script address\n        [ Spend <|\n            FromPlutusScript\n                { spentInput = lockedUtxoRef\n                , datumWitness = Nothing -- not needed, the datum was given by value\n                , plutusScriptWitness =\n                    { script = ( lockScript.version, WitnessValue lockScript.script )\n                    , redeemerData = \\_ -> dummyRedeemer -- unused\n                    , requiredSigners = [ myKeyCred ]\n                    }\n                }\n        , SendTo me twoAda\n\n        -- Return the other 2 ada to the lock script (there was 4 ada initially)\n        , SendToOutput\n            { address = scriptAddress\n            , amount = twoAda\n            , datumOption = Just (Datum datumWithKeyCred)\n            , referenceScript = Nothing\n            }\n        ]\n            |> finalize updatedState []\n\n\n## Code Documentation\n\n@docs TxIntent, SpendSource, InputsOutputs, ScriptWitness, PlutusScriptWitness, WitnessSource\n@docs CertificateIntent, CredentialWitness, VoterWitness\n@docs ProposalIntent, ActionProposal\n@docs TxOtherInfo\n@docs Fee\n@docs finalize, finalizeAdvanced, TxFinalizationError\n@docs GovernanceState, emptyGovernanceState\n@docs updateLocalState\n@docs dummyBytes\n\n","unions":[{"name":"ActionProposal","comment":" The different kinds of proposals available for governance.\n","args":[],"cases":[["ParameterChange",["Cardano.Gov.ProtocolParamUpdate"]],["HardForkInitiation",["Cardano.Gov.ProtocolVersion"]],["TreasuryWithdrawals",["List.List { destination : Cardano.Address.StakeAddress, amount : Natural.Natural }"]],["NoConfidence",[]],["UpdateCommittee",["{ removeMembers : List.List Cardano.Address.Credential, addMembers : List.List { newMember : Cardano.Address.Credential, expirationEpoch : Natural.Natural }, quorumThreshold : Cardano.Gov.UnitInterval }"]],["NewConstitution",["Cardano.Gov.Constitution"]],["Info",[]]]},{"name":"CertificateIntent","comment":" All intents requiring the on-chain publication of a certificate.\n\nThese include stake registration and delegation,\nstake pool management, and voting or delegating your voting power.\n\n","args":[],"cases":[["RegisterStake",["{ delegator : Cardano.CredentialWitness, deposit : Natural.Natural }"]],["UnregisterStake",["{ delegator : Cardano.CredentialWitness, refund : Natural.Natural }"]],["DelegateStake",["{ delegator : Cardano.CredentialWitness, poolId : Bytes.Comparable.Bytes Cardano.Transaction.PoolId }"]],["RegisterPool",["{ deposit : Natural.Natural }","Cardano.Transaction.PoolParams"]],["RetirePool",["{ poolId : Bytes.Comparable.Bytes Cardano.Transaction.PoolId, epoch : Natural.Natural }"]],["RegisterDrep",["{ drep : Cardano.CredentialWitness, deposit : Natural.Natural, info : Maybe.Maybe Cardano.Gov.Anchor }"]],["UnregisterDrep",["{ drep : Cardano.CredentialWitness, refund : Natural.Natural }"]],["VoteAlwaysAbstain",["{ delegator : Cardano.CredentialWitness }"]],["VoteAlwaysNoConfidence",["{ delegator : Cardano.CredentialWitness }"]],["DelegateVotes",["{ delegator : Cardano.CredentialWitness, drep : Cardano.Address.Credential }"]]]},{"name":"CredentialWitness","comment":" The type of credential to provide.\n\nIt can either be a key, typically from a wallet,\na native script, or a plutus script.\n\n","args":[],"cases":[["WithKey",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash"]],["WithScript",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash","Cardano.ScriptWitness"]]]},{"name":"Fee","comment":" Configure fees manually or automatically for a transaction.\n","args":[],"cases":[["ManualFee",["List.List { paymentSource : Cardano.Address.Address, exactFeeAmount : Natural.Natural }"]],["AutoFee",["{ paymentSource : Cardano.Address.Address }"]]]},{"name":"ScriptWitness","comment":" Represents different types of script witnesses.\n","args":[],"cases":[["NativeWitness",["Cardano.WitnessSource Cardano.Script.NativeScript"]],["PlutusWitness",["Cardano.PlutusScriptWitness"]]]},{"name":"SpendSource","comment":" Represents different sources for spending assets.\n\nTODO: check that output references match the type of source (script VS not script)\n\n","args":[],"cases":[["FromWallet",["Cardano.Address.Address","Cardano.Value.Value"]],["FromWalletUtxo",["Cardano.Utxo.OutputReference"]],["FromNativeScript",["{ spentInput : Cardano.Utxo.OutputReference, nativeScriptWitness : Cardano.WitnessSource Cardano.Script.NativeScript }"]],["FromPlutusScript",["{ spentInput : Cardano.Utxo.OutputReference, datumWitness : Maybe.Maybe (Cardano.WitnessSource Cardano.Data.Data), plutusScriptWitness : Cardano.PlutusScriptWitness }"]]]},{"name":"TxFinalizationError","comment":" Errors that may happen during Tx finalization.\n","args":[],"cases":[["UnableToGuessFeeSource",[]],["UnbalancedIntents",["String.String"]],["InsufficientManualFee",["{ declared : Natural.Natural, computed : Natural.Natural }"]],["NotEnoughMinAda",["String.String"]],["ReferenceOutputsMissingFromLocalState",["List.List Cardano.Utxo.OutputReference"]],["FailedToPerformCoinSelection",["Cardano.CoinSelection.Error"]],["CollateralSelectionError",["Cardano.CoinSelection.Error"]],["DuplicatedMetadataTags",["Basics.Int"]],["IncorrectTimeValidityRange",["String.String"]],["UplcVmError",["String.String"]],["GovProposalsNotSupportedInSimpleFinalize",[]],["FailurePleaseReportToElmCardano",["String.String"]]]},{"name":"TxIntent","comment":" Represents different types of transaction intents.\n","args":[],"cases":[["SendTo",["Cardano.Address.Address","Cardano.Value.Value"]],["SendToOutput",["Cardano.Utxo.Output"]],["SendToOutputAdvanced",["Cardano.InputsOutputs -> Cardano.Utxo.Output"]],["Spend",["Cardano.SpendSource"]],["MintBurn",["{ policyId : Bytes.Comparable.Bytes Cardano.Address.CredentialHash, assets : Bytes.Map.BytesMap Cardano.MultiAsset.AssetName Integer.Integer, scriptWitness : Cardano.ScriptWitness }"]],["IssueCertificate",["Cardano.CertificateIntent"]],["WithdrawRewards",["{ stakeCredential : Cardano.Address.StakeAddress, amount : Natural.Natural, scriptWitness : Maybe.Maybe Cardano.ScriptWitness }"]],["Vote",["Cardano.VoterWitness","List.List { actionId : Cardano.Gov.ActionId, vote : Cardano.Gov.Vote }"]],["Propose",["Cardano.ProposalIntent"]]]},{"name":"TxOtherInfo","comment":" Represents additional information for a transaction.\n","args":[],"cases":[["TxReferenceInput",["Cardano.Utxo.OutputReference"]],["TxMetadata",["{ tag : Natural.Natural, metadata : Cardano.Metadatum.Metadatum }"]],["TxTimeValidityRange",["{ start : Basics.Int, end : Natural.Natural }"]]]},{"name":"VoterWitness","comment":" Voting credentials can either come from\na DRep, a stake pool, or Constitutional Committee member.\n","args":[],"cases":[["WithCommitteeHotCred",["Cardano.CredentialWitness"]],["WithDrepCred",["Cardano.CredentialWitness"]],["WithPoolCred",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash"]]]},{"name":"WitnessSource","comment":" Represents different sources for witnesses.\n","args":["a"],"cases":[["WitnessValue",["a"]],["WitnessReference",["Cardano.Utxo.OutputReference"]]]}],"aliases":[{"name":"GovernanceState","comment":" Contains pointers to the latest enacted governance actions and to the constitution.\n","args":[],"type":"{ guardrailsScript : Maybe.Maybe { policyId : Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId, plutusVersion : Cardano.Script.PlutusVersion, scriptWitness : Cardano.WitnessSource (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor) }, lastEnactedCommitteeAction : Maybe.Maybe Cardano.Gov.ActionId, lastEnactedConstitutionAction : Maybe.Maybe Cardano.Gov.ActionId, lastEnactedHardForkAction : Maybe.Maybe Cardano.Gov.ActionId, lastEnactedProtocolParamUpdateAction : Maybe.Maybe Cardano.Gov.ActionId }"},{"name":"InputsOutputs","comment":" Represents the inputs and outputs of a transaction.\n","args":[],"type":"{ referenceInputs : List.List Cardano.Utxo.OutputReference, spentInputs : List.List Cardano.Utxo.OutputReference, createdOutputs : List.List Cardano.Utxo.Output }"},{"name":"PlutusScriptWitness","comment":" Represents a Plutus script witness.\n","args":[],"type":"{ script : ( Cardano.Script.PlutusVersion, Cardano.WitnessSource (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor) ), redeemerData : Cardano.InputsOutputs -> Cardano.Data.Data, requiredSigners : List.List (Bytes.Comparable.Bytes Cardano.Address.CredentialHash) }"},{"name":"ProposalIntent","comment":" Governance action proposal.\n","args":[],"type":"{ govAction : Cardano.ActionProposal, offchainInfo : Cardano.Gov.Anchor, deposit : Natural.Natural, depositReturnAccount : Cardano.Address.StakeAddress }"}],"values":[{"name":"dummyBytes","comment":" Unsafe helper function to make up some bytes of a given length,\nstarting by the given text when decoded as text.\n","type":"Basics.Int -> String.String -> Bytes.Comparable.Bytes a"},{"name":"emptyGovernanceState","comment":" Just a helper initialization for when we don’t care about governance proposals.\n","type":"Cardano.GovernanceState"},{"name":"finalize","comment":" Finalize a transaction before signing and sending it.\n\nAnalyze all intents and perform the following actions:\n\n  - Check the Tx balance\n  - Select the input UTxOs with a default coin selection algorithm\n  - Evaluate script execution costs with default mainnet parameters\n  - Try to find fee payment source automatically and compute automatic Tx fee\n\nThe network parameters will be automatically chosen to be:\n\n  - default Mainnet parameters if the guessed fee address is from Mainnet\n  - default Preview parameters if the guessed fee address is from a testnet.\n\nPreprod is not supported for this simplified [finalize] function.\nIn case you want more customization, please use [finalizeAdvanced].\n\n","type":"Cardano.Utxo.RefDict Cardano.Utxo.Output -> List.List Cardano.TxOtherInfo -> List.List Cardano.TxIntent -> Result.Result Cardano.TxFinalizationError Cardano.Transaction.Transaction"},{"name":"finalizeAdvanced","comment":" Finalize a transaction before signing and sending it.\n\nAnalyze all intents and perform the following actions:\n\n  - Check the Tx balance\n  - Select the input UTxOs with the provided coin selection algorithm\n  - Evaluate script execution costs with the provided function\n  - Compute Tx fee if set to auto\n\n","type":"{ govState : Cardano.GovernanceState, localStateUtxos : Cardano.Utxo.RefDict Cardano.Utxo.Output, coinSelectionAlgo : Cardano.CoinSelection.Algorithm, evalScriptsCosts : Cardano.Utxo.RefDict Cardano.Utxo.Output -> Cardano.Transaction.Transaction -> Result.Result String.String (List.List Cardano.Redeemer.Redeemer) } -> Cardano.Fee -> List.List Cardano.TxOtherInfo -> List.List Cardano.TxIntent -> Result.Result Cardano.TxFinalizationError Cardano.Transaction.Transaction"},{"name":"updateLocalState","comment":" Update the known local state with the spent and created UTxOs of a given transaction.\n","type":"Bytes.Comparable.Bytes Cardano.Utxo.TransactionId -> Cardano.Transaction.Transaction -> Cardano.Utxo.RefDict Cardano.Utxo.Output -> { updatedState : Cardano.Utxo.RefDict Cardano.Utxo.Output, spent : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), created : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ) }"}],"binops":[]},{"name":"Cardano.Address","comment":" Handling Cardano addresses.\n\n@docs Address, StakeAddress, NetworkId, ByronAddress\n\n@docs Credential, StakeCredential, StakeCredentialPointer, CredentialHash\n\n@docs fromBech32, fromBytes, enterprise, script, base, pointer\n\n@docs isShelleyWallet, extractCredentialHash, extractCredentialKeyHash, extractPubKeyHash, extractStakeCredential, extractStakeKeyHash\n\n@docs Dict, emptyDict, dictFromList\n\n@docs StakeDict, emptyStakeDict, stakeDictFromList\n\n@docs networkIdFromInt\n\n@docs toBytes, stakeAddressToBytes\n\n@docs toCbor, stakeAddressToCbor, credentialToCbor, encodeNetworkId\n\n@docs decode, decodeReward, decodeCredential\n\n","unions":[{"name":"Address","comment":" Full address, including the network ID.\n","args":[],"cases":[["Byron",["Bytes.Comparable.Bytes Cardano.Address.ByronAddress"]],["Shelley",["{ networkId : Cardano.Address.NetworkId, paymentCredential : Cardano.Address.Credential, stakeCredential : Maybe.Maybe Cardano.Address.StakeCredential }"]],["Reward",["Cardano.Address.StakeAddress"]]]},{"name":"ByronAddress","comment":" Phantom type for Byron addresses.\n","args":[],"cases":[]},{"name":"Credential","comment":" A general structure for representing an on-chain credential.\n\n[Credential] can represent both payment credentials or stake credentials.\n\nCredentials are always one of two kinds: a direct public/private key pair, or a script (native or Plutus).\n\n","args":[],"cases":[["VKeyHash",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash"]],["ScriptHash",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash"]]]},{"name":"CredentialHash","comment":" Phantom type for 28-bytes credential hashes,\ncorresponding either to VKey hashes or script hashes.\n\nThis is a Blake2b-224 hash.\n\n","args":[],"cases":[]},{"name":"NetworkId","comment":" The network ID of a transaction.\n","args":[],"cases":[["Testnet",[]],["Mainnet",[]]]},{"name":"StakeCredential","comment":" A StakeCredential represents the delegation and rewards withdrawal conditions associated with some stake address / account.\n\nA StakeCredential is either provided inline, or, by reference using an on-chain pointer.\nRead more about pointers in CIP-0019 :: Pointers.\n\n","args":[],"cases":[["InlineCredential",["Cardano.Address.Credential"]],["PointerCredential",["Cardano.Address.StakeCredentialPointer"]]]}],"aliases":[{"name":"Dict","comment":" Convenient alias for a `Dict` with [Address] keys.\nWhen converting to a `List`, its keys are sorted by address.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","args":["a"],"type":"Dict.Any.AnyDict String.String Cardano.Address.Address a"},{"name":"StakeAddress","comment":" An address type only use for things related to staking, such as delegation and reward withdrawals.\n","args":[],"type":"{ networkId : Cardano.Address.NetworkId, stakeCredential : Cardano.Address.Credential }"},{"name":"StakeCredentialPointer","comment":" A stake credential pointer.\n\nThis should not be used and is only present for compatibility with previous eras.\n\n","args":[],"type":"{ slotNumber : Basics.Int, transactionIndex : Basics.Int, certificateIndex : Basics.Int }"},{"name":"StakeDict","comment":" Convenient alias for a `Dict` with [StakeAddress] keys.\nWhen converting to a `List`, its keys are sorted by stake address.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","args":["a"],"type":"Dict.Any.AnyDict ( Basics.Int, String.String ) Cardano.Address.StakeAddress a"}],"values":[{"name":"base","comment":" Create a base address with a payement credential and a stake credential.\n","type":"Cardano.Address.NetworkId -> Cardano.Address.Credential -> Cardano.Address.Credential -> Cardano.Address.Address"},{"name":"credentialToCbor","comment":" CBOR encoder for a [Credential], be it for payment or for stake.\n","type":"Cardano.Address.Credential -> Cbor.Encode.Encoder"},{"name":"decode","comment":" CBOR decoder for [Address].\n","type":"Cbor.Decode.Decoder Cardano.Address.Address"},{"name":"decodeCredential","comment":" Decode [Credential] which is either from a key or a script.\n","type":"Cbor.Decode.Decoder Cardano.Address.Credential"},{"name":"decodeReward","comment":" CBOR decoder for [StakeAddress].\nThis only succeeds for a valid [Address] of the [Reward] variant.\n","type":"Cbor.Decode.Decoder Cardano.Address.StakeAddress"},{"name":"dictFromList","comment":" Create an address dictionary from a list.\nFor other operations, use the `AnyDict` module directly.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"List.List ( Cardano.Address.Address, a ) -> Cardano.Address.Dict a"},{"name":"emptyDict","comment":" Initialize an empty address dictionary.\nFor other operations, use the `AnyDict` module directly.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"Cardano.Address.Dict a"},{"name":"emptyStakeDict","comment":" Initialize an empty stake address dictionary.\nFor other operations, use the `AnyDict` module directly.\n\nThe keys order are derived from Haskell auto-derived credential order.\nMeaning Script first, then VKey.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"Cardano.Address.StakeDict a"},{"name":"encodeNetworkId","comment":" CBOR encoder for [NetworkId].\n","type":"Cardano.Address.NetworkId -> Cbor.Encode.Encoder"},{"name":"enterprise","comment":" Create a simple enterprise address, with only a payment credential and no stake credential.\n","type":"Cardano.Address.NetworkId -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash -> Cardano.Address.Address"},{"name":"extractCredentialHash","comment":" Extract the credential hash (either key hash or script hash).\n","type":"Cardano.Address.Credential -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash"},{"name":"extractCredentialKeyHash","comment":" Extract the credential key hash (Nothing if it’s a script).\n","type":"Cardano.Address.Credential -> Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Address.CredentialHash)"},{"name":"extractPubKeyHash","comment":" Extract the pubkey hash of a Shelley wallet address.\n","type":"Cardano.Address.Address -> Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Address.CredentialHash)"},{"name":"extractStakeCredential","comment":" Extract the stake credential part of a Shelley address.\n","type":"Cardano.Address.Address -> Maybe.Maybe Cardano.Address.StakeCredential"},{"name":"extractStakeKeyHash","comment":" Extract the stake key hash of a Shelley address.\n","type":"Cardano.Address.Address -> Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Address.CredentialHash)"},{"name":"fromBech32","comment":" Build an [Address] from its Bech32 string representation.\n","type":"String.String -> Maybe.Maybe Cardano.Address.Address"},{"name":"fromBytes","comment":" Convert an [Address] from its [Bytes] representation.\n","type":"Bytes.Comparable.Bytes a -> Maybe.Maybe Cardano.Address.Address"},{"name":"isShelleyWallet","comment":" Check if an [Address] is of the Shelley type, with a wallet payment key, not a script.\n","type":"Cardano.Address.Address -> Basics.Bool"},{"name":"networkIdFromInt","comment":" Convert to [NetworkId] from its integer representation.\n","type":"Basics.Int -> Maybe.Maybe Cardano.Address.NetworkId"},{"name":"pointer","comment":" Create a pointer address.\n","type":"Cardano.Address.NetworkId -> Cardano.Address.Credential -> { slotNumber : Basics.Int, transactionIndex : Basics.Int, certificateIndex : Basics.Int } -> Cardano.Address.Address"},{"name":"script","comment":" Create a simple script address, with only a payment credential and no stake credential.\n","type":"Cardano.Address.NetworkId -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash -> Cardano.Address.Address"},{"name":"stakeAddressToBytes","comment":" Convert a stake address to its bytes representation.\n","type":"Cardano.Address.StakeAddress -> Bytes.Comparable.Bytes Cardano.Address.StakeAddress"},{"name":"stakeAddressToCbor","comment":" CBOR encoder for a stake address.\n","type":"Cardano.Address.StakeAddress -> Cbor.Encode.Encoder"},{"name":"stakeDictFromList","comment":" Create a stake address dictionary from a list.\nFor other operations, use the `AnyDict` module directly.\n\nThe keys order are derived from Haskell auto-derived credential order.\nMeaning Script first, then VKey.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"List.List ( Cardano.Address.StakeAddress, a ) -> Cardano.Address.StakeDict a"},{"name":"toBytes","comment":" Convert an [Address] to its underlying [Bytes] representation.\n\nByron addresses are left untouched as we don't plan to have full support of Byron era.\n\nShelley address description from CIP-0019:\n\n    Header type (tttt....)  Payment Part     Delegation Part\n    (0) 0000....            PaymentKeyHash   StakeKeyHash\n    (1) 0001....            ScriptHash       StakeKeyHash\n    (2) 0010....            PaymentKeyHash   ScriptHash\n    (3) 0011....            ScriptHash       ScriptHash\n    (4) 0100....            PaymentKeyHash   Pointer\n    (5) 0101....            ScriptHash       Pointer\n    (6) 0110....            PaymentKeyHash   ø\n    (7) 0111....            ScriptHash       ø\n\n    Header type (....tttt)\n    (0) ....0000 testnet\n    (1) ....0001 mainnet\n\nFor example, `61....(56 chars / 28 bytes)....` is an enterprise address (6, only a payment key) on mainnet (1).\n\nStake address description from CIP-0019:\n\n    Header type (tttt....)  Stake Reference\n    (14) 1110....           StakeKeyHash\n    (15) 1111....           ScriptHash\n\n","type":"Cardano.Address.Address -> Bytes.Comparable.Bytes Cardano.Address.Address"},{"name":"toCbor","comment":" Encode an [Address] to CBOR.\n","type":"Cardano.Address.Address -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.AuxiliaryData","comment":"\n\n@docs AuxiliaryData, fromJustLabels\n\n@docs hash, Hash\n\n@docs fromCbor, toCbor\n\n","unions":[{"name":"Hash","comment":" Phantom type for auxiliary data hashes.\nThis is a 32-bytes Blake2b-256 hash.\n","args":[],"cases":[]}],"aliases":[{"name":"AuxiliaryData","comment":" [Transaction] auxiliary data.\n","args":[],"type":"{ labels : List.List ( Natural.Natural, Cardano.Metadatum.Metadatum ), nativeScripts : List.List Cardano.Script.NativeScript, plutusV1Scripts : List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor), plutusV2Scripts : List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor), plutusV3Scripts : List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor) }"}],"values":[{"name":"fromCbor","comment":" Decode transaction auxiliary data from CBOR.\n","type":"Cbor.Decode.Decoder Cardano.AuxiliaryData.AuxiliaryData"},{"name":"fromJustLabels","comment":" Create [AuxiliaryData] with just labels, no scripts.\n","type":"List.List ( Natural.Natural, Cardano.Metadatum.Metadatum ) -> Cardano.AuxiliaryData.AuxiliaryData"},{"name":"hash","comment":" Compute auxiliary data hash.\n","type":"Cardano.AuxiliaryData.AuxiliaryData -> Bytes.Comparable.Bytes Cardano.AuxiliaryData.Hash"},{"name":"toCbor","comment":" Encode transaction auxiliary data to CBOR.\n","type":"Cardano.AuxiliaryData.AuxiliaryData -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.Cip30","comment":" CIP 30 support.\n\n@docs WalletDescriptor, Wallet, walletDescriptor\n\n@docs Request, encodeRequest, Paginate\n\n@docs discoverWallets, enableWallet\n\n@docs getExtensions, getNetworkId, getUtxos, getCollateral, getBalance\n\n@docs getUsedAddresses, getUnusedAddresses, getChangeAddress, getRewardAddresses\n\n@docs signTx, signTxCbor, signData, submitTx, submitTxCbor\n\n@docs Response, ApiResponse, Utxo, DataSignature, responseDecoder\n\n","unions":[{"name":"ApiResponse","comment":" Response type for all API requests done through the `api` object returned when enabling a wallet.\n","args":[],"cases":[["Extensions",["List.List Basics.Int"]],["NetworkId",["Cardano.Address.NetworkId"]],["WalletUtxos",["List.List Cardano.Cip30.Utxo"]],["Collateral",["List.List Cardano.Cip30.Utxo"]],["WalletBalance",["Cardano.Value.Value"]],["UsedAddresses",["List.List Cardano.Address.Address"]],["UnusedAddresses",["List.List Cardano.Address.Address"]],["ChangeAddress",["Cardano.Address.Address"]],["RewardAddresses",["List.List Cardano.Address.Address"]],["SignedTx",["List.List Cardano.Transaction.VKeyWitness"]],["SignedData",["Cardano.Cip30.DataSignature"]],["SubmittedTx",["Bytes.Comparable.Bytes Cardano.Utxo.TransactionId"]]]},{"name":"Request","comment":" Opaque type for requests to be sent to the wallets.\n","args":[],"cases":[]},{"name":"Response","comment":" Response type for responses from the browser wallets.\n","args":[],"cases":[["AvailableWallets",["List.List Cardano.Cip30.WalletDescriptor"]],["EnabledWallet",["Cardano.Cip30.Wallet"]],["ApiResponse",["{ walletId : String.String }","Cardano.Cip30.ApiResponse"]],["ApiError",["{ code : Basics.Int, info : String.String }"]],["UnhandledResponseType",["String.String"]]]},{"name":"Wallet","comment":" Opaque Wallet object to be used for all API requests.\n","args":[],"cases":[]}],"aliases":[{"name":"DataSignature","comment":" Signature returned from the wallet after signing a payload with your stake key.\n","args":[],"type":"{ signature : Cbor.CborItem, key : Cbor.CborItem }"},{"name":"Paginate","comment":" Paginate requests that may return many elements.\n","args":[],"type":"{ page : Basics.Int, limit : Basics.Int }"},{"name":"Utxo","comment":" UTxO type holding the reference and actual output.\n","args":[],"type":"( Cardano.Utxo.OutputReference, Cardano.Utxo.Output )"},{"name":"WalletDescriptor","comment":" The type returned when asking for available wallets.\n","args":[],"type":"{ id : String.String, name : String.String, icon : String.String, apiVersion : String.String, isEnabled : Basics.Bool, supportedExtensions : List.List Basics.Int }"}],"values":[{"name":"discoverWallets","comment":" Typically the first request you have to send, to discover which wallets are installed.\n\nWill typically be followed by a response of the [AvailableWallets] variant\ncontaining a [WalletDescriptor] for each discovered wallet.\n\n","type":"Cardano.Cip30.Request"},{"name":"enableWallet","comment":" Enable an installed wallet.\n\nWill typically be followed by a response of the [EnabledWallet] variant\ncontaining a [Wallet] to be stored in your model.\n\n","type":"{ id : String.String, extensions : List.List Basics.Int } -> Cardano.Cip30.Request"},{"name":"encodeRequest","comment":" Encode a [Request] into a JS value that can be sent through a port.\n","type":"Cardano.Cip30.Request -> Json.Decode.Value"},{"name":"getBalance","comment":" Get the current wallet balance.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getChangeAddress","comment":" Get an address that can be used to send funds to this wallet.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getCollateral","comment":" Get a list of UTxOs to be used for collateral.\n\nYou need to specify the amount of lovelace you need for collateral.\nMore info about why that is in the [CIP 30 spec][cip-collateral].\n\n[cip-collateral]: https://cips.cardano.org/cips/cip30/#apigetcollateralparamsamountcborcoinpromisetransactionunspentoutputnull\n\n","type":"Cardano.Cip30.Wallet -> { amount : Natural.Natural } -> Cardano.Cip30.Request"},{"name":"getExtensions","comment":" Get the list of extensions enabled by the wallet.\n\nThis feature isn't well supported yet by wallets (as of 2023-10).\n\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getNetworkId","comment":" Get the current network ID of the wallet.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getRewardAddresses","comment":" Get addresses used to withdraw staking rewards.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getUnusedAddresses","comment":" Get a list of unused addresses.\n\nAvoid this feature if possible.\nIt is not consistent and not compatible with single-address wallets.\n\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getUsedAddresses","comment":" Get a list of used addresses from the wallet.\n\nThat list is wallet-dependent and may not contain all used addresses.\nDo not rely on this as a source of truth to get all addresses of a user.\n\n","type":"Cardano.Cip30.Wallet -> { paginate : Maybe.Maybe Cardano.Cip30.Paginate } -> Cardano.Cip30.Request"},{"name":"getUtxos","comment":" Get a list of UTxOs in the wallet.\n","type":"Cardano.Cip30.Wallet -> { amount : Maybe.Maybe Cardano.Value.Value, paginate : Maybe.Maybe Cardano.Cip30.Paginate } -> Cardano.Cip30.Request"},{"name":"responseDecoder","comment":" Decoder for the [Response] type.\n","type":"Json.Decode.Decoder Cardano.Cip30.Response"},{"name":"signData","comment":" Sign an arbitrary payload with your stake key.\n","type":"Cardano.Cip30.Wallet -> { addr : String.String, payload : Bytes.Comparable.Bytes a } -> Cardano.Cip30.Request"},{"name":"signTx","comment":" Sign a transaction.\n","type":"Cardano.Cip30.Wallet -> { partialSign : Basics.Bool } -> Cardano.Transaction.Transaction -> Cardano.Cip30.Request"},{"name":"signTxCbor","comment":" Sign a transaction, already CBOR-encoded (to avoid deserialization-serialization mismatch).\n","type":"Cardano.Cip30.Wallet -> { partialSign : Basics.Bool } -> Bytes.Comparable.Bytes Cardano.Transaction.Transaction -> Cardano.Cip30.Request"},{"name":"submitTx","comment":" Encode a transaction and submit it via the wallet.\n","type":"Cardano.Cip30.Wallet -> Cardano.Transaction.Transaction -> Cardano.Cip30.Request"},{"name":"submitTxCbor","comment":" Submit a transaction, already CBOR-encoded (to avoid deserialization-serialization mismatch).\n","type":"Cardano.Cip30.Wallet -> Bytes.Comparable.Bytes Cardano.Transaction.Transaction -> Cardano.Cip30.Request"},{"name":"walletDescriptor","comment":" Retrieve the descriptor associated with a [Wallet] object.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.WalletDescriptor"}],"binops":[]},{"name":"Cardano.Cip67","comment":" CIP-0067 support.\n\nCIP-0067 [describes](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0067)\na standard format for assets so that their purpose can be deduced solely by\ntheir token names. So far, the primary application of this standard is to\neasily distinguish between CIP-0068 assets and their reference counterparts.\n\n@docs Cip67, AssetName\n\n@docs fromBytes, labelFromHex, fromCbor\n\n@docs toBytes, labelToHex, toCbor\n\n","unions":[{"name":"AssetName","comment":" Phantom type for CIP-0067 asset names with the label prefix removed.\n","args":[],"cases":[]}],"aliases":[{"name":"Cip67","comment":" Datatype for modeling CIP-0067.\n\nThis standard offers a label number preceding the actual token name, which can\nbe from `0` to `65535` (i.e. 2 bytes, and left-padded with `00` for numbers\nsmaller than 2 bytes). This label should be formatted as such:\n\n    --  openning bracket                             closing bracket\n    --       ┌──┐                                         ┌──┐\n    --     [ 0000 | 16 bits label_num | 8 bits checksum | 0000 ]\n    --              └───────────────┘   └───────┬─────┘\n    --        fixed 2 bytes for the label       │\n    --                                          │\n    -- label's checksum found by applying the CRC-8 algorithm to its 2 bytes\n\n\n\nThe [polynomial representation](https://wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Polynomial_representations)\nof the CRC-8 is `0x07` (`0b00000111`).\n\nAs an example, a label of `222` turn into: `0x000de140`\n\n1.  Hex equivalent of decimal `222` is `0xde`\n2.  Since it's less than 2 bytes, we add `0x00` to the left and get `0x00de`\n3.  Find its CRC-8 checksum (`0x14`)\n4.  Concatenate the two and wrap in \"brackets\" to get the final bytes: `0x000de140`\n\nFinally, a complete CIP-0067 example:\n\n\n    spacebudz2921 : Maybe Cip67\n    spacebudz2921 =\n        Maybe.andThen Cip67.fromBytes <| Bytes.fromHex \"000de14042756432393231\"\n\n    -- Just { assetName = Bytes \"42756432393231\", label = 222 }\n\n","args":[],"type":"{ label : Basics.Int, assetName : Bytes.Comparable.Bytes Cardano.Cip67.AssetName }"}],"values":[{"name":"fromBytes","comment":" Validate and separate the label of a CIP-0067 asset name.\n\nGiven a valid CIP-0067 token name [Bytes], this function separates the label as\nan [Int], and returns the asset name without the label bytes.\n\n","type":"Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName -> Maybe.Maybe Cardano.Cip67.Cip67"},{"name":"fromCbor","comment":" CBOR decoder for [Cip67].\n","type":"Cbor.Decode.Decoder Cardano.Cip67.Cip67"},{"name":"labelFromHex","comment":" Extract the label if it is valid. Return Nothing otherwise.\n","type":"String.String -> Maybe.Maybe Basics.Int"},{"name":"labelToHex","comment":" Convert an Int label into its CIP-0067 hex string.\n","type":"Basics.Int -> String.String"},{"name":"toBytes","comment":" Converts a [Cip67] to [Bytes].\n","type":"Cardano.Cip67.Cip67 -> Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName"},{"name":"toCbor","comment":" CBOR encoder.\n","type":"Cardano.Cip67.Cip67 -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.CoinSelection","comment":" Module `Cardano.CoinSelection` provides functionality for performing\ncoin selection based on a set of available UTXOs and a set of requested outputs.\nIt exports functions for sorting UTXOs and performing the Largest-First coin\nselection algorithm as described in CIP2 (<https://cips.cardano.org/cips/cip2/>).\n\n\n# Types\n\n@docs Context, Error, Selection, Algorithm\n\n\n# Strategies\n\n@docs largestFirst\n\n","unions":[{"name":"Error","comment":" Enumerates the possible errors that can occur during coin selection.\n","args":[],"cases":[["MaximumInputCountExceeded",[]],["UTxOBalanceInsufficient",["{ selectedUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), missingValue : Cardano.Value.Value }"]]]}],"aliases":[{"name":"Algorithm","comment":" Alias for the function signature of a utxo selection algorithm.\n","args":[],"type":"Basics.Int -> Cardano.CoinSelection.Context -> Result.Result Cardano.CoinSelection.Error Cardano.CoinSelection.Selection"},{"name":"Context","comment":" Holds the arguments necessary for performing coin selection.\n","args":[],"type":"{ availableUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), alreadySelectedUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), targetAmount : Cardano.Value.Value }"},{"name":"Selection","comment":" Represents the result of a successful coin selection.\n","args":[],"type":"{ selectedUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), change : Maybe.Maybe Cardano.Value.Value }"}],"values":[{"name":"largestFirst","comment":" Implements the Largest-First coin selection algorithm as described in CIP2.\n\nTakes a `Context` record containing the available UTXOs, initially\nselected UTXOs, requested outputs, and change address, along with an `Int`\nrepresenting the maximum number of inputs allowed. Returns either a\n`Error` or a `Selection`. See <https://cips.cardano.org/cips/cip2/#largestfirst>\n\nTODO: if possible, remove extraneous inputs.\nIndeed, when selecting later CNT, they might contain enough previous CNT too.\n\n","type":"Basics.Int -> Cardano.CoinSelection.Context -> Result.Result Cardano.CoinSelection.Error Cardano.CoinSelection.Selection"}],"binops":[]},{"name":"Cardano.Data","comment":" Handling Cardano Data objects.\n\n@docs Data, fromCbor, toCbor\n\n","unions":[{"name":"Data","comment":" A Data is a compound type that can represent any possible user-defined type in Aiken.\n","args":[],"cases":[["Constr",["Natural.Natural","List.List Cardano.Data.Data"]],["Map",["List.List ( Cardano.Data.Data, Cardano.Data.Data )"]],["List",["List.List Cardano.Data.Data"]],["Int",["Integer.Integer"]],["Bytes",["Bytes.Comparable.Bytes Bytes.Comparable.Any"]]]}],"aliases":[],"values":[{"name":"fromCbor","comment":" CBOR decoder for [Data].\n","type":"Cbor.Decode.Decoder Cardano.Data.Data"},{"name":"toCbor","comment":" CBOR encoder for [Data].\n","type":"Cardano.Data.Data -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.Gov","comment":" Handling gov-related stuff.\n\n@docs Drep, decodeDrep, encodeDrep\n\n@docs ProposalProcedure, proposalProcedureFromCbor\n\n@docs Action, decodeAction, encodeAction\n\n@docs ActionId, actionIdFromCbor, encodeActionId\n\n@docs Constitution, decodeConstitution, encodeConstitution\n\n@docs ProtocolParamUpdate, noParamUpdate, decodeProtocolParamUpdate, encodeProtocolParamUpdate\n\n@docs PoolVotingThresholds, decodePoolVotingThresholds, encodePoolVotingThresholds\n\n@docs DrepVotingThresholds, decodeDrepVotingThresholds, encodeDrepVotingThresholds\n\n@docs CostModels, decodeCostModels, encodeCostModels\n\n@docs ProtocolVersion, decodeProtocolVersion, encodeProtocolVersion\n\n@docs Nonce, UnitInterval, PositiveInterval\n\n@docs VotingProcedure, votingProcedureFromCbor, encodeVotingProcedure\n\n@docs Vote, encodeVote\n\n@docs Voter, VoterDict, emptyVoterDict, voterDictFromList, voterCredentialHash, voterKeyCred, voterLedgerOrder, voterFromCbor, encodeVoter\n\n@docs Anchor, AnchorDataHash, decodeAnchor, encodeAnchor\n\n","unions":[{"name":"Action","comment":" Represents different types of governance actions.\n","args":[],"cases":[["ParameterChange",["{ latestEnacted : Maybe.Maybe Cardano.Gov.ActionId, protocolParamUpdate : Cardano.Gov.ProtocolParamUpdate, guardrailsPolicy : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId) }"]],["HardForkInitiation",["{ latestEnacted : Maybe.Maybe Cardano.Gov.ActionId, protocolVersion : Cardano.Gov.ProtocolVersion }"]],["TreasuryWithdrawals",["{ withdrawals : List.List ( Cardano.Address.StakeAddress, Natural.Natural ), guardrailsPolicy : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId) }"]],["NoConfidence",["{ latestEnacted : Maybe.Maybe Cardano.Gov.ActionId }"]],["UpdateCommittee",["{ latestEnacted : Maybe.Maybe Cardano.Gov.ActionId, removedMembers : List.List Cardano.Address.Credential, addedMembers : List.List { newMember : Cardano.Address.Credential, expirationEpoch : Natural.Natural }, quorumThreshold : Cardano.Gov.UnitInterval }"]],["NewConstitution",["{ latestEnacted : Maybe.Maybe Cardano.Gov.ActionId, constitution : Cardano.Gov.Constitution }"]],["Info",[]]]},{"name":"AnchorDataHash","comment":" Opaque phantom type for an [Anchor] data hash.\nIt is 32-bytes long.\n","args":[],"cases":[]},{"name":"Drep","comment":" Delegate representative.\n","args":[],"cases":[["DrepCredential",["Cardano.Address.Credential"]],["AlwaysAbstain",[]],["AlwaysNoConfidence",[]]]},{"name":"Nonce","comment":" Represents a nonce for extra entropy.\n","args":[],"cases":[["Just0",[]],["RandomBytes",["Bytes.Comparable.Bytes Bytes.Comparable.Any"]]]},{"name":"Vote","comment":" Represents different types of votes.\n","args":[],"cases":[["VoteNo",[]],["VoteYes",[]],["VoteAbstain",[]]]},{"name":"Voter","comment":" Represents different types of voters.\n","args":[],"cases":[["VoterCommitteeHotCred",["Cardano.Address.Credential"]],["VoterDrepCred",["Cardano.Address.Credential"]],["VoterPoolId",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash"]]]}],"aliases":[{"name":"ActionId","comment":" Represents an action ID.\n","args":[],"type":"{ transactionId : Bytes.Comparable.Bytes Cardano.Utxo.TransactionId, govActionIndex : Basics.Int }"},{"name":"Anchor","comment":" Represents an anchor for governance actions.\n","args":[],"type":"{ url : String.String, dataHash : Bytes.Comparable.Bytes Cardano.Gov.AnchorDataHash }"},{"name":"Constitution","comment":" Represents a constitution.\n","args":[],"type":"{ anchor : Cardano.Gov.Anchor, scripthash : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Address.CredentialHash) }"},{"name":"CostModels","comment":" Represents cost models for different Plutus versions.\n","args":[],"type":"{ plutusV1 : Maybe.Maybe (List.List Basics.Int), plutusV2 : Maybe.Maybe (List.List Basics.Int), plutusV3 : Maybe.Maybe (List.List Basics.Int) }"},{"name":"DrepVotingThresholds","comment":" Represents voting thresholds for delegate representatives.\n","args":[],"type":"{ motionNoConfidence : Cardano.Gov.UnitInterval, committeeNormal : Cardano.Gov.UnitInterval, committeeNoConfidence : Cardano.Gov.UnitInterval, updateConstitution : Cardano.Gov.UnitInterval, hardforkInitiation : Cardano.Gov.UnitInterval, ppNetworkGroup : Cardano.Gov.UnitInterval, ppEconomicGroup : Cardano.Gov.UnitInterval, ppTechnicalGroup : Cardano.Gov.UnitInterval, ppGovernanceGroup : Cardano.Gov.UnitInterval, treasuryWithdrawal : Cardano.Gov.UnitInterval }"},{"name":"PoolVotingThresholds","comment":" Represents voting thresholds for stake pools.\n","args":[],"type":"{ motionNoConfidence : Cardano.Gov.UnitInterval, committeeNormal : Cardano.Gov.UnitInterval, committeeNoConfidence : Cardano.Gov.UnitInterval, hardforkInitiation : Cardano.Gov.UnitInterval, securityRelevantParameter : Cardano.Gov.UnitInterval }"},{"name":"PositiveInterval","comment":" Represents a positive interval (> 0).\n","args":[],"type":"Cardano.Utils.RationalNumber"},{"name":"ProposalProcedure","comment":" Represents a proposal procedure.\n","args":[],"type":"{ deposit : Natural.Natural, depositReturnAccount : Cardano.Address.StakeAddress, govAction : Cardano.Gov.Action, anchor : Cardano.Gov.Anchor }"},{"name":"ProtocolParamUpdate","comment":" Adjustable parameters that power key aspects of the network.\n","args":[],"type":"{ minFeeA : Maybe.Maybe Natural.Natural, minFeeB : Maybe.Maybe Natural.Natural, maxBlockBodySize : Maybe.Maybe Basics.Int, maxTransactionSize : Maybe.Maybe Basics.Int, maxBlockHeaderSize : Maybe.Maybe Basics.Int, keyDeposit : Maybe.Maybe Natural.Natural, poolDeposit : Maybe.Maybe Natural.Natural, maximumEpoch : Maybe.Maybe Natural.Natural, desiredNumberOfStakePools : Maybe.Maybe Basics.Int, poolPledgeInfluence : Maybe.Maybe Cardano.Utils.RationalNumber, expansionRate : Maybe.Maybe Cardano.Gov.UnitInterval, treasuryGrowthRate : Maybe.Maybe Cardano.Gov.UnitInterval, decentralizationConstant : Maybe.Maybe Cardano.Gov.UnitInterval, extraEntropy : Maybe.Maybe Cardano.Gov.Nonce, protocolVersion : Maybe.Maybe Cardano.Gov.ProtocolVersion, minUtxoValue : Maybe.Maybe Natural.Natural, minPoolCost : Maybe.Maybe Natural.Natural, adaPerUtxoByte : Maybe.Maybe Natural.Natural, costModelsForScriptLanguages : Maybe.Maybe Cardano.Gov.CostModels, executionCosts : Maybe.Maybe Cardano.Redeemer.ExUnitPrices, maxTxExUnits : Maybe.Maybe Cardano.Redeemer.ExUnits, maxBlockExUnits : Maybe.Maybe Cardano.Redeemer.ExUnits, maxValueSize : Maybe.Maybe Basics.Int, collateralPercentage : Maybe.Maybe Basics.Int, maxCollateralInputs : Maybe.Maybe Basics.Int, poolVotingThresholds : Maybe.Maybe Cardano.Gov.PoolVotingThresholds, drepVotingThresholds : Maybe.Maybe Cardano.Gov.DrepVotingThresholds, minCommitteeSize : Maybe.Maybe Basics.Int, committeeTermLimit : Maybe.Maybe Natural.Natural, governanceActionValidityPeriod : Maybe.Maybe Natural.Natural, governanceActionDeposit : Maybe.Maybe Natural.Natural, drepDeposit : Maybe.Maybe Natural.Natural, drepInactivityPeriod : Maybe.Maybe Natural.Natural, minFeeRefScriptCostPerByte : Maybe.Maybe Basics.Int }"},{"name":"ProtocolVersion","comment":" Represents a protocol version.\n","args":[],"type":"( Basics.Int, Basics.Int )"},{"name":"UnitInterval","comment":" Represents a unit interval (0 to 1).\n","args":[],"type":"Cardano.Utils.RationalNumber"},{"name":"VoterDict","comment":" Convenient alias for a `Dict` with [Voter] keys.\nWhen converting to a `List`, its keys are sorted with the same order as the Haskell node.\nThe order is determined by [voterLedgerOrder].\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","args":["a"],"type":"Dict.Any.AnyDict ( Basics.Int, String.String ) Cardano.Gov.Voter a"},{"name":"VotingProcedure","comment":" Represents a voting procedure.\n","args":[],"type":"{ vote : Cardano.Gov.Vote, anchor : Maybe.Maybe Cardano.Gov.Anchor }"}],"values":[{"name":"actionIdFromCbor","comment":" Decoder for ActionId type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.ActionId"},{"name":"decodeAction","comment":" Decoder for Action type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.Action"},{"name":"decodeAnchor","comment":" Decoder for Anchor type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.Anchor"},{"name":"decodeConstitution","comment":" Decoder for Constitution type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.Constitution"},{"name":"decodeCostModels","comment":" Decoder for CostModels type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.CostModels"},{"name":"decodeDrep","comment":" Decoder for Drep type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.Drep"},{"name":"decodeDrepVotingThresholds","comment":" Decoder for DrepVotingThresholds type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.DrepVotingThresholds"},{"name":"decodePoolVotingThresholds","comment":" Decoder for PoolVotingThresholds type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.PoolVotingThresholds"},{"name":"decodeProtocolParamUpdate","comment":" Decoder for ProtocolParamUpdate type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.ProtocolParamUpdate"},{"name":"decodeProtocolVersion","comment":" Decoder for ProtocolVersion type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.ProtocolVersion"},{"name":"emptyVoterDict","comment":" Create a empty voter dictionary.\nFor other operations, use the `AnyDict` module directly.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"Cardano.Gov.VoterDict a"},{"name":"encodeAction","comment":" Encoder for Action type.\n","type":"Cardano.Gov.Action -> Cbor.Encode.Encoder"},{"name":"encodeActionId","comment":" Encoder for ActionId type.\n","type":"Cardano.Gov.ActionId -> Cbor.Encode.Encoder"},{"name":"encodeAnchor","comment":" Encoder for Anchor type.\n","type":"Cardano.Gov.Anchor -> Cbor.Encode.Encoder"},{"name":"encodeConstitution","comment":" Encoder for Constitution type.\n","type":"Cardano.Gov.Constitution -> Cbor.Encode.Encoder"},{"name":"encodeCostModels","comment":" Encode [CostModels] to CBOR.\n","type":"Cardano.Gov.CostModels -> Cbor.Encode.Encoder"},{"name":"encodeDrep","comment":" Encoder for Drep type.\n","type":"Cardano.Gov.Drep -> Cbor.Encode.Encoder"},{"name":"encodeDrepVotingThresholds","comment":" Encoder for DrepVotingThresholds type.\n","type":"Cardano.Gov.DrepVotingThresholds -> Cbor.Encode.Encoder"},{"name":"encodePoolVotingThresholds","comment":" Encoder for PoolVotingThresholds type.\n","type":"Cardano.Gov.PoolVotingThresholds -> Cbor.Encode.Encoder"},{"name":"encodeProtocolParamUpdate","comment":" Encoder for ProtocolParamUpdate type.\n","type":"Cardano.Gov.ProtocolParamUpdate -> Cbor.Encode.Encoder"},{"name":"encodeProtocolVersion","comment":" Encoder for ProtocolVersion type.\n","type":"Cardano.Gov.ProtocolVersion -> Cbor.Encode.Encoder"},{"name":"encodeVote","comment":" Encoder for Vote type.\n","type":"Cardano.Gov.Vote -> Cbor.Encode.Encoder"},{"name":"encodeVoter","comment":" Encoder for Voter type.\n","type":"Cardano.Gov.Voter -> Cbor.Encode.Encoder"},{"name":"encodeVotingProcedure","comment":" Encoder for VotingProcedure type.\n","type":"Cardano.Gov.VotingProcedure -> Cbor.Encode.Encoder"},{"name":"noParamUpdate","comment":" Default (no update) for [ProtocolParamUpdate].\n","type":"Cardano.Gov.ProtocolParamUpdate"},{"name":"proposalProcedureFromCbor","comment":" Decoder for ProposalProcedure type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.ProposalProcedure"},{"name":"voterCredentialHash","comment":" Extract the credential hash of a voter.\n","type":"Cardano.Gov.Voter -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash"},{"name":"voterDictFromList","comment":" Create a voter dictionary from a list.\nFor other operations, use the `AnyDict` module directly.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"List.List ( Cardano.Gov.Voter, a ) -> Cardano.Gov.VoterDict a"},{"name":"voterFromCbor","comment":" Decoder for Voter type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.Voter"},{"name":"voterKeyCred","comment":" Helper function to extract keys that would need signing.\n","type":"Cardano.Gov.Voter -> Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Address.CredentialHash)"},{"name":"voterLedgerOrder","comment":" Helper function to help sort voters for redeemers in the same order as Haskell node.\n\nThe problem is that the ledger code sort these maps with auto derived order.\nAnd the Credential definition uses ScriptHash first, instead of VKeyHash first.\n<https://github.com/IntersectMBO/cardano-ledger/blob/2f199b94716350b5fbd6c07505eb333d89cffa90/libs/cardano-ledger-core/src/Cardano/Ledger/Credential.hs#L85>\n\n","type":"Cardano.Gov.Voter -> ( Basics.Int, String.String )"},{"name":"votingProcedureFromCbor","comment":" Decoder for VotingProcedure type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.VotingProcedure"}],"binops":[]},{"name":"Cardano.Interval","comment":" In a eUTxO-based blockchain like Cardano, the management of time can be finicky.\nIndeed, in order to maintain a complete determinism in the execution of scripts, it is impossible to introduce a notion of \"current time\".\nThe execution would then depend on factor that are external to the transaction itself: the ineluctable stream of time flowing in our universe.\nHence, to work around that, we typically define time intervals, within which the transaction can be executed.\nFrom within a script, it isn’t possible to know when exactly the script is executed, but we can reason about the interval bounds to validate pieces of logic.\n\n@docs Interval, Bound, BoundType\n\n","unions":[{"name":"BoundType","comment":" The bound type, which can be finite or infinite.\n","args":["a"],"cases":[["NegativeInfinity",[]],["Finite",["a"]],["PositiveInfinity",[]]]}],"aliases":[{"name":"Bound","comment":" Bound of an interval.\n","args":["a"],"type":"{ boundType : Cardano.Interval.BoundType a, isInclusive : Basics.Bool }"},{"name":"Interval","comment":" A type to represent intervals of values, with finite or infinite bounds.\n","args":["a"],"type":"{ lowerBound : Cardano.Interval.Bound a, upperBound : Cardano.Interval.Bound a }"}],"values":[],"binops":[]},{"name":"Cardano.Metadatum","comment":"\n\n@docs Metadatum, fromCbor, toCbor\n\n","unions":[{"name":"Metadatum","comment":" Transaction auxiliary data metadatum.\n","args":[],"cases":[["Int",["Integer.Integer"]],["Bytes",["Bytes.Comparable.Bytes Bytes.Comparable.Any"]],["String",["String.String"]],["List",["List.List Cardano.Metadatum.Metadatum"]],["Map",["List.List ( Cardano.Metadatum.Metadatum, Cardano.Metadatum.Metadatum )"]]]}],"aliases":[],"values":[{"name":"fromCbor","comment":" Decode Metadatum from CBOR\n","type":"Cbor.Decode.Decoder Cardano.Metadatum.Metadatum"},{"name":"toCbor","comment":" Encode Metadatum to CBOR.\n","type":"Cardano.Metadatum.Metadatum -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.MultiAsset","comment":" Handling multi-asset values.\n\n@docs MultiAsset, PolicyId, AssetName\n@docs isEmpty, get, empty, onlyToken, normalize, mintAdd\n@docs balance, map2, split\n@docs coinsToCbor, mintToCbor, coinsFromCbor, mintFromCbor\n\n","unions":[{"name":"AssetName","comment":" Phantom type for asset names.\nThis is a free-form bytes array of length <= 32 bytes.\n","args":[],"cases":[]}],"aliases":[{"name":"MultiAsset","comment":" Type alias for handling multi-asset values.\n\nThis type should maintain some invariants by construction.\nIn particular, it should never contain a zero quantity of a particular token.\n\nTODO: make sure the previous statement stays true by construction.\nThis would require an opaque type for MultiAsset.\n\n","args":["int"],"type":"Bytes.Map.BytesMap Cardano.MultiAsset.PolicyId (Bytes.Map.BytesMap Cardano.MultiAsset.AssetName int)"},{"name":"PolicyId","comment":" Phantom type for 28-bytes policy id.\nThis is a Blacke2b-224 hash.\n","args":[],"type":"Cardano.Address.CredentialHash"}],"values":[{"name":"balance","comment":" Compute a mint balance.\n","type":"Bytes.Map.BytesMap Cardano.MultiAsset.AssetName Integer.Integer -> { minted : Bytes.Map.BytesMap Cardano.MultiAsset.AssetName Natural.Natural, burned : Bytes.Map.BytesMap Cardano.MultiAsset.AssetName Natural.Natural }"},{"name":"coinsFromCbor","comment":" CBOR decoder for [MultiAsset] coins.\n","type":"Cbor.Decode.Decoder (Cardano.MultiAsset.MultiAsset Natural.Natural)"},{"name":"coinsToCbor","comment":" CBOR encoder for [MultiAsset] coins.\n","type":"Cardano.MultiAsset.MultiAsset Natural.Natural -> Cbor.Encode.Encoder"},{"name":"empty","comment":" Create an empty [MultiAsset].\n","type":"Cardano.MultiAsset.MultiAsset a"},{"name":"get","comment":" Retrieve the amount of a given token.\n","type":"Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId -> Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName -> Cardano.MultiAsset.MultiAsset a -> Maybe.Maybe a"},{"name":"isEmpty","comment":" Check if the [MultiAsset] contains no token.\n","type":"Cardano.MultiAsset.MultiAsset a -> Basics.Bool"},{"name":"map2","comment":" Apply a function for each token pair of two [MultiAsset].\nAbsent tokens in one [MultiAsset] are replaced by the default value.\n","type":"(a -> a -> b) -> a -> Cardano.MultiAsset.MultiAsset a -> Cardano.MultiAsset.MultiAsset a -> Cardano.MultiAsset.MultiAsset b"},{"name":"mintAdd","comment":" Add together two mint values.\n","type":"Cardano.MultiAsset.MultiAsset Integer.Integer -> Cardano.MultiAsset.MultiAsset Integer.Integer -> Cardano.MultiAsset.MultiAsset Integer.Integer"},{"name":"mintFromCbor","comment":" CBOR decoder for [MultiAsset] mints.\n","type":"Cbor.Decode.Decoder (Cardano.MultiAsset.MultiAsset Integer.Integer)"},{"name":"mintToCbor","comment":" CBOR encoder for [MultiAsset] mints.\n","type":"Cardano.MultiAsset.MultiAsset Integer.Integer -> Cbor.Encode.Encoder"},{"name":"normalize","comment":" Remove assets with 0 amounts.\n","type":"(int -> Basics.Bool) -> Cardano.MultiAsset.MultiAsset int -> Cardano.MultiAsset.MultiAsset int"},{"name":"onlyToken","comment":" Create a singleton [MultiAsset].\n","type":"Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId -> Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName -> int -> Cardano.MultiAsset.MultiAsset int"},{"name":"split","comment":" Split a [MultiAsset] into a list of each individual asset `(policyId, assetName, amount)`.\n","type":"Cardano.MultiAsset.MultiAsset a -> List.List ( Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId, Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName, a )"}],"binops":[]},{"name":"Cardano.Redeemer","comment":" Redeemer\n\n@docs Redeemer, RedeemerTag, ExUnits\n@docs ExUnitPrices, feeCost, decodeExUnitPrices, encodeExUnitPrices\n@docs encodeAsArray, encodeTag, encodeExUnits\n@docs fromCborArray, tagFromCbor, exUnitsFromCbor\n\n","unions":[{"name":"RedeemerTag","comment":" Indicator of the type of validator associated with this redeemer.\n","args":[],"cases":[["Spend",[]],["Mint",[]],["Cert",[]],["Reward",[]],["Vote",[]],["Propose",[]]]}],"aliases":[{"name":"ExUnitPrices","comment":" Represents execution unit prices.\n","args":[],"type":"{ memPrice : Cardano.Utils.RationalNumber, stepPrice : Cardano.Utils.RationalNumber }"},{"name":"ExUnits","comment":" Cost of the script in memory and instruction steps.\n","args":[],"type":"{ mem : Basics.Int, steps : Basics.Int }"},{"name":"Redeemer","comment":" Redeemer of a script, containing the data passed as argument to the validator.\n","args":[],"type":"{ tag : Cardano.Redeemer.RedeemerTag, index : Basics.Int, data : Cardano.Data.Data, exUnits : Cardano.Redeemer.ExUnits }"}],"values":[{"name":"decodeExUnitPrices","comment":" Decoder for ExUnitPrices type.\n","type":"Cbor.Decode.Decoder Cardano.Redeemer.ExUnitPrices"},{"name":"encodeAsArray","comment":" CBOR encoder for a [Redeemer].\n","type":"Cardano.Redeemer.Redeemer -> Cbor.Encode.Encoder"},{"name":"encodeExUnitPrices","comment":" Encoder for ExUnitPrices type.\n","type":"Cardano.Redeemer.ExUnitPrices -> Cbor.Encode.Encoder"},{"name":"encodeExUnits","comment":" CBOR encoder for [ExUnits].\n","type":"Cardano.Redeemer.ExUnits -> Cbor.Encode.Encoder"},{"name":"encodeTag","comment":" CBOR encoder for a [RedeemerTag].\n","type":"Cardano.Redeemer.RedeemerTag -> Cbor.Encode.Encoder"},{"name":"exUnitsFromCbor","comment":" CBOR decoder for [ExUnits].\n","type":"Cbor.Decode.Decoder Cardano.Redeemer.ExUnits"},{"name":"feeCost","comment":" Helper function to compute a give redeemer cost in fees.\n","type":"Cardano.Redeemer.ExUnitPrices -> Cardano.Redeemer.ExUnits -> Natural.Natural"},{"name":"fromCborArray","comment":" CBOR decoder for [Redeemer].\n","type":"Cbor.Decode.Decoder Cardano.Redeemer.Redeemer"},{"name":"tagFromCbor","comment":" CBOR decoder for [Tag].\n","type":"Cbor.Decode.Decoder Cardano.Redeemer.RedeemerTag"}],"binops":[]},{"name":"Cardano.Script","comment":" Script\n\n@docs Script, NativeScript, NativeScriptPubkeyHash, PlutusScript, PlutusVersion, ScriptCbor\n\n\n## Encoders\n\n@docs toCbor, encodeNativeScript, encodePlutusScript\n\n\n## Decoders\n\n@docs fromCbor, decodeNativeScript\n\n","unions":[{"name":"NativeScript","comment":" A native script\n<https://github.com/txpipe/pallas/blob/d1ac0561427a1d6d1da05f7b4ea21414f139201e/pallas-primitives/src/alonzo/model.rs#L772>\n","args":[],"cases":[["ScriptPubkey",["Bytes.Comparable.Bytes Cardano.Script.NativeScriptPubkeyHash"]],["ScriptAll",["List.List Cardano.Script.NativeScript"]],["ScriptAny",["List.List Cardano.Script.NativeScript"]],["ScriptNofK",["Basics.Int","List.List Cardano.Script.NativeScript"]],["InvalidBefore",["Natural.Natural"]],["InvalidHereafter",["Natural.Natural"]]]},{"name":"NativeScriptPubkeyHash","comment":" Phantom type for 28-bytes native script public key hash.\nThis is a Blake2b-224 hash.\n","args":[],"cases":[]},{"name":"PlutusVersion","comment":" The plutus version.\n","args":[],"cases":[["PlutusV1",[]],["PlutusV2",[]],["PlutusV3",[]]]},{"name":"Script","comment":" Cardano script, either a native script or a plutus script.\n\n`script = [ 0, native_script // 1, plutus_v1_script // 2, plutus_v2_script ]`\n\n[Babbage implementation in Pallas][pallas].\n\n[pallas]: https://github.com/txpipe/pallas/blob/d1ac0561427a1d6d1da05f7b4ea21414f139201e/pallas-primitives/src/babbage/model.rs#L58\n\n","args":[],"cases":[["Native",["Cardano.Script.NativeScript"]],["Plutus",["Cardano.Script.PlutusScript"]]]},{"name":"ScriptCbor","comment":" Phantom type describing the kind of bytes within a [PlutusScript] object.\n","args":[],"cases":[]}],"aliases":[{"name":"PlutusScript","comment":" A plutus script.\n","args":[],"type":"{ version : Cardano.Script.PlutusVersion, script : Bytes.Comparable.Bytes Cardano.Script.ScriptCbor }"}],"values":[{"name":"decodeNativeScript","comment":" Decode NativeScript from CBOR.\n","type":"Cbor.Decode.Decoder Cardano.Script.NativeScript"},{"name":"encodeNativeScript","comment":" Cbor Encoder for [NativeScript]\n","type":"Cardano.Script.NativeScript -> Cbor.Encode.Encoder"},{"name":"encodePlutusScript","comment":" Cbor Encoder for PlutusScript\n","type":"Cardano.Script.PlutusScript -> Cbor.Encode.Encoder"},{"name":"fromCbor","comment":" CBOR decoder for [Script].\n\nThis does not contain the double CBOR decoding of the `script_ref` UTxO field.\nThat part has to be handled in the UTxO decoder.\n\n","type":"Cbor.Decode.Decoder Cardano.Script.Script"},{"name":"toCbor","comment":" Cbor Encoder for [Script]\n","type":"Cardano.Script.Script -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.Transaction","comment":" Types and functions related to on-chain transactions.\n\n@docs Transaction, new\n\n@docs TransactionBody, newBody, ScriptDataHash\n\n@docs WitnessSet, newWitnessSet\n\n@docs Update\n\n@docs ScriptContext, ScriptPurpose\n\n@docs Certificate, PoolId, GenesisHash, GenesisDelegateHash, VrfKeyHash, RewardSource, RewardTarget, MoveInstantaneousReward\n\n@docs Relay, IpV4, IpV6, PoolParams, PoolMetadata, PoolMetadataHash\n\n@docs VKeyWitness, BootstrapWitness, Ed25519PublicKey, Ed25519Signature, BootstrapWitnessChainCode, BootstrapWitnessAttributes\n\n@docs FeeParameters, RefScriptFeeParameters, defaultTxFeeParams, computeFees, allInputs\n\n@docs updateSignatures, hashScriptData\n\n@docs deserialize, serialize, encodeToCbor\n\n@docs decodeWitnessSet\n\n","unions":[{"name":"BootstrapWitnessAttributes","comment":" Phantom type for [BootstrapWitness] attributes.\nBytes of this type can be of any length.\n","args":[],"cases":[]},{"name":"BootstrapWitnessChainCode","comment":" Phantom type for [BootstrapWitness] chain code.\nIt has a length of 32 bytes.\n","args":[],"cases":[]},{"name":"Certificate","comment":" An on-chain certificate attesting of some operation.\nPublishing certificates triggers different kind of rules.\nMost of the time, they require signatures from specific keys.\n","args":[],"cases":[["StakeRegistrationCert",["{ delegator : Cardano.Address.Credential }"]],["StakeDeregistrationCert",["{ delegator : Cardano.Address.Credential }"]],["StakeDelegationCert",["{ delegator : Cardano.Address.Credential, poolId : Bytes.Comparable.Bytes Cardano.Transaction.PoolId }"]],["PoolRegistrationCert",["Cardano.Transaction.PoolParams"]],["PoolRetirementCert",["{ poolId : Bytes.Comparable.Bytes Cardano.Transaction.PoolId, epoch : Natural.Natural }"]],["GenesisKeyDelegationCert",["{ genesisHash : Bytes.Comparable.Bytes Cardano.Transaction.GenesisHash, genesisDelegateHash : Bytes.Comparable.Bytes Cardano.Transaction.GenesisDelegateHash, vrfKeyHash : Bytes.Comparable.Bytes Cardano.Transaction.VrfKeyHash }"]],["MoveInstantaneousRewardsCert",["Cardano.Transaction.MoveInstantaneousReward"]],["RegCert",["{ delegator : Cardano.Address.Credential, deposit : Natural.Natural }"]],["UnregCert",["{ delegator : Cardano.Address.Credential, refund : Natural.Natural }"]],["VoteDelegCert",["{ delegator : Cardano.Address.Credential, drep : Cardano.Gov.Drep }"]],["StakeVoteDelegCert",["{ delegator : Cardano.Address.Credential, poolId : Bytes.Comparable.Bytes Cardano.Transaction.PoolId, drep : Cardano.Gov.Drep }"]],["StakeRegDelegCert",["{ delegator : Cardano.Address.Credential, poolId : Bytes.Comparable.Bytes Cardano.Transaction.PoolId, deposit : Natural.Natural }"]],["VoteRegDelegCert",["{ delegator : Cardano.Address.Credential, drep : Cardano.Gov.Drep, deposit : Natural.Natural }"]],["StakeVoteRegDelegCert",["{ delegator : Cardano.Address.Credential, poolId : Bytes.Comparable.Bytes Cardano.Transaction.PoolId, drep : Cardano.Gov.Drep, deposit : Natural.Natural }"]],["AuthCommitteeHotCert",["{ committeeColdCredential : Cardano.Address.Credential, committeeHotCredential : Cardano.Address.Credential }"]],["ResignCommitteeColdCert",["{ committeeColdCredential : Cardano.Address.Credential, anchor : Maybe.Maybe Cardano.Gov.Anchor }"]],["RegDrepCert",["{ drepCredential : Cardano.Address.Credential, deposit : Natural.Natural, anchor : Maybe.Maybe Cardano.Gov.Anchor }"]],["UnregDrepCert",["{ drepCredential : Cardano.Address.Credential, refund : Natural.Natural }"]],["UpdateDrepCert",["{ drepCredential : Cardano.Address.Credential, anchor : Maybe.Maybe Cardano.Gov.Anchor }"]]]},{"name":"Ed25519PublicKey","comment":" Phantom type for ED25519 public keys, of length 32 bytes.\n","args":[],"cases":[]},{"name":"Ed25519Signature","comment":" Phantom type for ED25519 signatures, of length 64 bytes.\n","args":[],"cases":[]},{"name":"GenesisDelegateHash","comment":" Phantom type for Genesis delegate hash.\nThis is a 28-bytes Blake2b-224 hash.\n","args":[],"cases":[]},{"name":"GenesisHash","comment":" Phantom type for Genesis hash.\nThis is a 28-bytes Blake2b-224 hash.\n","args":[],"cases":[]},{"name":"IpV4","comment":" Phantom type for 4-bytes IPV4 addresses.\n","args":[],"cases":[]},{"name":"IpV6","comment":" Phantom type for 16-bytes IPV6 addresses.\n","args":[],"cases":[]},{"name":"PoolMetadataHash","comment":" Phantom type for 32-bytes pool metadata hash.\nThis is a Blacke2b-256 hash.\n","args":[],"cases":[]},{"name":"Relay","comment":" A pool's relay information.\n","args":[],"cases":[["SingleHostAddr",["{ port_ : Maybe.Maybe Basics.Int, ipv4 : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Transaction.IpV4), ipv6 : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Transaction.IpV6) }"]],["SingleHostName",["{ port_ : Maybe.Maybe Basics.Int, dnsName : String.String }"]],["MultiHostName",["{ dnsName : String.String }"]]]},{"name":"RewardSource","comment":" The source of rewards.\n","args":[],"cases":[["Reserves",[]],["Treasury",[]]]},{"name":"RewardTarget","comment":" Reward target for a certificate's [MoveInstantaneousReward].\n\nIf `StakeCredentials`, funds are moved to stake credentials,\notherwise the funds are given to the other accounting pot.\n\n","args":[],"cases":[["StakeCredentials",["List.List ( Cardano.Address.Credential, Natural.Natural )"]],["OtherAccountingPot",["Natural.Natural"]]]},{"name":"ScriptDataHash","comment":" Phantom type for script data hashes.\nThis is a 32-bytes Blake2b-256 hash.\n","args":[],"cases":[]},{"name":"ScriptPurpose","comment":" Characterizes the kind of script being executed and the associated resource.\n","args":[],"cases":[["SPMint",["{ policyId : Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId }"]],["SPSpend",["Cardano.Utxo.OutputReference"]],["SPWithdrawFrom",["Cardano.Address.Credential"]],["SPPublish",["Cardano.Transaction.Certificate"]]]},{"name":"VrfKeyHash","comment":" Phantom type for VRF key hash.\nThis is a 32-bytes Blake2b-256 hash.\n","args":[],"cases":[]}],"aliases":[{"name":"BootstrapWitness","comment":" Bootstrap witness\n","args":[],"type":"{ publicKey : Bytes.Comparable.Bytes Cardano.Transaction.Ed25519PublicKey, signature : Bytes.Comparable.Bytes Cardano.Transaction.Ed25519Signature, chainCode : Bytes.Comparable.Bytes Cardano.Transaction.BootstrapWitnessChainCode, attributes : Bytes.Comparable.Bytes Cardano.Transaction.BootstrapWitnessAttributes }"},{"name":"FeeParameters","comment":" Parameters required to compute transaction fees.\n","args":[],"type":"{ baseFee : Basics.Int, feePerByte : Basics.Int, scriptExUnitPrice : Cardano.Redeemer.ExUnitPrices, refScriptFeeParams : Cardano.Transaction.RefScriptFeeParameters }"},{"name":"MoveInstantaneousReward","comment":" Payload for [MoveInstantaneousRewardsCert].\n","args":[],"type":"{ source : Cardano.Transaction.RewardSource, target : Cardano.Transaction.RewardTarget }"},{"name":"PoolId","comment":" Phantom type for pool ID.\nThis is a 28-bytes Blake2b-224 hash.\n\n-- TODO: Move Pool stuff into its own module\n\n","args":[],"type":"Cardano.Address.CredentialHash"},{"name":"PoolMetadata","comment":" A pool's metadata hash.\n","args":[],"type":"{ url : String.String, poolMetadataHash : Bytes.Comparable.Bytes Cardano.Transaction.PoolMetadataHash }"},{"name":"PoolParams","comment":" Parameters for stake pool registration.\n","args":[],"type":"{ operator : Bytes.Comparable.Bytes Cardano.Transaction.PoolId, vrfKeyHash : Bytes.Comparable.Bytes Cardano.Transaction.VrfKeyHash, pledge : Natural.Natural, cost : Natural.Natural, margin : Cardano.Gov.UnitInterval, rewardAccount : Cardano.Address.StakeAddress, poolOwners : List.List (Bytes.Comparable.Bytes Cardano.Address.CredentialHash), relays : List.List Cardano.Transaction.Relay, poolMetadata : Maybe.Maybe Cardano.Transaction.PoolMetadata }"},{"name":"RefScriptFeeParameters","comment":" Parameters for the costs of referencing scripts.\n\nFull explanation of the formula here:\n<https://github.com/IntersectMBO/cardano-ledger/blob/master/docs/adr/2024-08-14_009-refscripts-fee-change.md>\n\n","args":[],"type":"{ minFeeRefScriptCostPerByte : Basics.Int, multiplier : Cardano.Utils.RationalNumber, sizeIncrement : Basics.Int }"},{"name":"ScriptContext","comment":" A context given to a script by the Cardano ledger when being executed.\n\nThe context contains information about the entire transaction that contains the script.\nThe transaction may also contain other scripts.\nTo distinguish between multiple scripts, the ScriptContext contains a \"purpose\" identifying the current resource triggering this execution.\n\n","args":[],"type":"{ transaction : Cardano.Transaction.Transaction, purpose : Cardano.Transaction.ScriptPurpose }"},{"name":"Transaction","comment":" A Cardano transaction.\n","args":[],"type":"{ body : Cardano.Transaction.TransactionBody, witnessSet : Cardano.Transaction.WitnessSet, isValid : Basics.Bool, auxiliaryData : Maybe.Maybe Cardano.AuxiliaryData.AuxiliaryData }"},{"name":"TransactionBody","comment":" A Cardano transaction body.\n","args":[],"type":"{ inputs : List.List Cardano.Utxo.OutputReference, outputs : List.List Cardano.Utxo.Output, fee : Natural.Natural, ttl : Maybe.Maybe Natural.Natural, certificates : List.List Cardano.Transaction.Certificate, withdrawals : List.List ( Cardano.Address.StakeAddress, Natural.Natural ), update : Maybe.Maybe Cardano.Transaction.Update, auxiliaryDataHash : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.AuxiliaryData.Hash), validityIntervalStart : Maybe.Maybe Basics.Int, mint : Cardano.MultiAsset.MultiAsset Integer.Integer, scriptDataHash : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Transaction.ScriptDataHash), collateral : List.List Cardano.Utxo.OutputReference, requiredSigners : List.List (Bytes.Comparable.Bytes Cardano.Address.CredentialHash), networkId : Maybe.Maybe Cardano.Address.NetworkId, collateralReturn : Maybe.Maybe Cardano.Utxo.Output, totalCollateral : Maybe.Maybe Basics.Int, referenceInputs : List.List Cardano.Utxo.OutputReference, votingProcedures : List.List ( Cardano.Gov.Voter, List.List ( Cardano.Gov.ActionId, Cardano.Gov.VotingProcedure ) ), proposalProcedures : List.List Cardano.Gov.ProposalProcedure, currentTreasuryValue : Maybe.Maybe Natural.Natural, treasuryDonation : Maybe.Maybe Natural.Natural }"},{"name":"Update","comment":" Payload to update the protocol parameters at a specific epoch\n","args":[],"type":"{ proposedProtocolParameterUpdates : Bytes.Map.BytesMap Cardano.Transaction.GenesisHash Cardano.Gov.ProtocolParamUpdate, epoch : Natural.Natural }"},{"name":"VKeyWitness","comment":" VKey witness\n","args":[],"type":"{ vkey : Bytes.Comparable.Bytes Cardano.Transaction.Ed25519PublicKey, signature : Bytes.Comparable.Bytes Cardano.Transaction.Ed25519Signature }"},{"name":"WitnessSet","comment":" A Cardano transaction witness set.\n\n[Pallas alonzo implementation][pallas]\n\n[pallas]: https://github.com/txpipe/pallas/blob/d1ac0561427a1d6d1da05f7b4ea21414f139201e/pallas-primitives/src/alonzo/model.rs#L763\n\n","args":[],"type":"{ vkeywitness : Maybe.Maybe (List.List Cardano.Transaction.VKeyWitness), nativeScripts : Maybe.Maybe (List.List Cardano.Script.NativeScript), bootstrapWitness : Maybe.Maybe (List.List Cardano.Transaction.BootstrapWitness), plutusV1Script : Maybe.Maybe (List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor)), plutusData : Maybe.Maybe (List.List Cardano.Data.Data), redeemer : Maybe.Maybe (List.List Cardano.Redeemer.Redeemer), plutusV2Script : Maybe.Maybe (List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor)), plutusV3Script : Maybe.Maybe (List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor)) }"}],"values":[{"name":"allInputs","comment":" Extract all inputs that are used in the transaction,\nfrom inputs, collateral and reference inputs.\n","type":"Cardano.Transaction.Transaction -> Cardano.Utxo.RefDict ()"},{"name":"computeFees","comment":" Re-compute fees for a transaction (does not read `body.fee`).\n","type":"Cardano.Transaction.FeeParameters -> { refScriptBytes : Basics.Int } -> Cardano.Transaction.Transaction -> { txSizeFee : Natural.Natural, scriptExecFee : Natural.Natural, refScriptSizeFee : Natural.Natural }"},{"name":"decodeWitnessSet","comment":" Decode a [WitnessSet] from CBOR.\n","type":"Cbor.Decode.Decoder Cardano.Transaction.WitnessSet"},{"name":"defaultTxFeeParams","comment":" Default values for fee parameters.\n","type":"Cardano.Transaction.FeeParameters"},{"name":"deserialize","comment":" Deserialize a transaction's cbor bytes into a [Transaction]\n","type":"Bytes.Comparable.Bytes a -> Maybe.Maybe Cardano.Transaction.Transaction"},{"name":"encodeToCbor","comment":" Encode a Tx to CBOR\n","type":"Cardano.Transaction.Transaction -> Cbor.Encode.Encoder"},{"name":"hashScriptData","comment":" Compute the script data hash of the transaction.\n\nThe caller must know what versions of Plutus scripts are present in the Tx\nand provide accordingly the associated cost models.\n\nScript data is serialized in a very specific way to compute the hash.\nSee Conway CDDL format: <https://github.com/IntersectMBO/cardano-ledger/blob/676ffc5c3e0dddb2b1ddeb76627541b195fefb5a/eras/conway/impl/cddl-files/conway.cddl#L197>\n\n","type":"Cardano.Gov.CostModels -> Cardano.Transaction.Transaction -> Bytes.Comparable.Bytes Cardano.Transaction.ScriptDataHash"},{"name":"new","comment":" Helper for empty [Transaction] initialization.\n","type":"Cardano.Transaction.Transaction"},{"name":"newBody","comment":" Helper for empty transaction body initialization.\n","type":"Cardano.Transaction.TransactionBody"},{"name":"newWitnessSet","comment":" Helper for empty witness set initialization.\n","type":"Cardano.Transaction.WitnessSet"},{"name":"serialize","comment":" Serialize a [Transaction] into cbor bytes\n","type":"Cardano.Transaction.Transaction -> Bytes.Comparable.Bytes Cardano.Transaction.Transaction"},{"name":"updateSignatures","comment":" Clear all signatures from the witness set of the Tx.\n","type":"(Maybe.Maybe (List.List Cardano.Transaction.VKeyWitness) -> Maybe.Maybe (List.List Cardano.Transaction.VKeyWitness)) -> Cardano.Transaction.Transaction -> Cardano.Transaction.Transaction"}],"binops":[]},{"name":"Cardano.Uplc","comment":" Handling the UPLC VM\n\n@docs evalScriptsCosts, evalScriptsCostsRaw\n\n@docs VmConfig, defaultVmConfig, conwayDefaultBudget, conwayDefaultCostModels\n\n@docs SlotConfig, slotConfigMainnet, slotConfigPreview, slotConfigPreprod\n\n","unions":[],"aliases":[{"name":"SlotConfig","comment":" Time managing config for the VM.\n","args":[],"type":"{ zeroTime : Natural.Natural, zeroSlot : Natural.Natural, slotLengthMs : Basics.Int }"},{"name":"VmConfig","comment":" UPLC VM configuration.\n\nThis is required so that the VM knows how to price memory usage and execution steps,\nas well as how to manage time.\n\n","args":[],"type":"{ budget : Cardano.Redeemer.ExUnits, slotConfig : Cardano.Uplc.SlotConfig, costModels : Cardano.Gov.CostModels }"}],"values":[{"name":"conwayDefaultBudget","comment":" The default budget currently in the Conway era.\n","type":"Cardano.Redeemer.ExUnits"},{"name":"conwayDefaultCostModels","comment":" Default cost models for the Plutus VM currently in the Conway era.\n","type":"Cardano.Gov.CostModels"},{"name":"defaultVmConfig","comment":" Default UPLC VM config.\n","type":"Cardano.Uplc.VmConfig"},{"name":"evalScriptsCosts","comment":" Evaluate Plutus scripts costs.\n\nThis also checks that the provided local state has all relevant UTxOs present.\n\nThis function will call Aiken UPLC VM with some JavaScript and WebAssembly code.\nIt requires customized Elm compilation and JS code patching,\nso you need to call the `elm-cardano` binary for compilation.\nMore info on that in the `README` of the [elm-cardano GitHub repo](https://github.com/mpizenberg/elm-cardano).\n\n","type":"Cardano.Uplc.VmConfig -> Cardano.Utxo.RefDict Cardano.Utxo.Output -> Cardano.Transaction.Transaction -> Result.Result String.String (List.List Cardano.Redeemer.Redeemer)"},{"name":"evalScriptsCostsRaw","comment":" Evaluate plutus scripts costs with the Tx raw bytes.\n\nThis function will call Aiken UPLC VM with some JavaScript and WebAssembly code.\nIt requires customized Elm compilation and JS code patching,\nso you need to call the `elm-cardano` binary for compilation.\nMore info on that in the `README` of the [elm-cardano GitHub repo](https://github.com/mpizenberg/elm-cardano).\n\n","type":"Cardano.Uplc.VmConfig -> Cardano.Utxo.RefDict Cardano.Utxo.Output -> Bytes.Comparable.Bytes any -> Result.Result String.String (List.List Cardano.Redeemer.Redeemer)"},{"name":"slotConfigMainnet","comment":" Default slot config for Mainnet.\n","type":"Cardano.Uplc.SlotConfig"},{"name":"slotConfigPreprod","comment":" Default slot config for Preprod.\n","type":"Cardano.Uplc.SlotConfig"},{"name":"slotConfigPreview","comment":" Default slot config for Preview.\n","type":"Cardano.Uplc.SlotConfig"}],"binops":[]},{"name":"Cardano.Utils","comment":" Just a utility module to avoid cyclic import dependencies.\n\n@docs RationalNumber, decodeRational, encodeRationalNumber\n\n","unions":[],"aliases":[{"name":"RationalNumber","comment":" Represents a rational number.\n","args":[],"type":"{ numerator : Basics.Int, denominator : Basics.Int }"}],"values":[{"name":"decodeRational","comment":" Decoder for RationalNumber type.\n","type":"Cbor.Decode.Decoder Cardano.Utils.RationalNumber"},{"name":"encodeRationalNumber","comment":" Encoder for RationalNumber type.\n","type":"Cardano.Utils.RationalNumber -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.Utxo","comment":" Handling outputs.\n\n\n## Definitions\n\n@docs OutputReference, TransactionId, Output, DatumHash, DatumOption\n\n\n## Dictionary with [OutputReference] keys\n\n@docs RefDict, emptyRefDict, refDictFromList\n\n\n## Build\n\n@docs fromLovelace, simpleOutput\n\n\n## Display\n\n@docs refAsString\n\n\n## Query\n\n@docs lovelace, totalLovelace, compareLovelace, isAdaOnly\n\n\n## Compute\n\n@docs minAda, checkMinAda, minAdaForAssets\n\n\n## Convert\n\n@docs encodeOutputReference, encodeOutput, encodeDatumOption\n\n@docs decodeOutputReference, decodeOutput\n\n","unions":[{"name":"DatumHash","comment":" Phantom type for 32-bytes datum hashes.\nThis is a Blake2b-256 hash.\n","args":[],"cases":[]},{"name":"DatumOption","comment":" Nickname for data stored in a eUTxO.\n","args":[],"cases":[["DatumHash",["Bytes.Comparable.Bytes Cardano.Utxo.DatumHash"]],["DatumValue",["Cardano.Data.Data"]]]},{"name":"TransactionId","comment":" Phantom type for 32-bytes transaction IDs.\nThis is a Blake2b-256 hash.\n","args":[],"cases":[]}],"aliases":[{"name":"Output","comment":" The content of a eUTxO.\n","args":[],"type":"{ address : Cardano.Address.Address, amount : Cardano.Value.Value, datumOption : Maybe.Maybe Cardano.Utxo.DatumOption, referenceScript : Maybe.Maybe Cardano.Script.Script }"},{"name":"OutputReference","comment":" The reference for a eUTxO.\n","args":[],"type":"{ transactionId : Bytes.Comparable.Bytes Cardano.Utxo.TransactionId, outputIndex : Basics.Int }"},{"name":"RefDict","comment":" Convenience type for `Dict` with [OutputReference] keys.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","args":["a"],"type":"Dict.Any.AnyDict ( String.String, Basics.Int ) Cardano.Utxo.OutputReference a"}],"values":[{"name":"checkMinAda","comment":" Check that an [Output] has enough ada to cover its size.\n","type":"Cardano.Utxo.Output -> Result.Result String.String Cardano.Utxo.Output"},{"name":"compareLovelace","comment":" Compare UTxOs by lovelace value.\n","type":"Cardano.Utxo.Output -> Cardano.Utxo.Output -> Basics.Order"},{"name":"decodeOutput","comment":" CBOR decoder for an [Output].\n","type":"Cbor.Decode.Decoder Cardano.Utxo.Output"},{"name":"decodeOutputReference","comment":" Decode an [OutputReference], such as for transaction inputs.\n","type":"Cbor.Decode.Decoder Cardano.Utxo.OutputReference"},{"name":"emptyRefDict","comment":" Convenience empty initialization for `Dict` with [OutputReference] keys.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"Cardano.Utxo.RefDict a"},{"name":"encodeDatumOption","comment":" CBOR encoder for [DatumOption].\n","type":"Cardano.Utxo.DatumOption -> Cbor.Encode.Encoder"},{"name":"encodeOutput","comment":" CBOR encoder for [Output].\n","type":"Cardano.Utxo.Output -> Cbor.Encode.Encoder"},{"name":"encodeOutputReference","comment":" CBOR encoder for [OutputReference].\n","type":"Cardano.Utxo.OutputReference -> Cbor.Encode.Encoder"},{"name":"fromLovelace","comment":" Construct an `Output` from an `Address` and a lovelace amount\n","type":"Cardano.Address.Address -> Natural.Natural -> Cardano.Utxo.Output"},{"name":"isAdaOnly","comment":" Check if the output contains only Ada.\nNothing else is allowed, no tokens, no datum, no ref script.\n","type":"Cardano.Utxo.Output -> Basics.Bool"},{"name":"lovelace","comment":" Extract the amount of lovelace in an `Output`\n","type":"Cardano.Utxo.Output -> Natural.Natural"},{"name":"minAda","comment":" Compute minimum Ada lovelace for a given [Output].\n\nSince the size of the lovelace field may impact minAda,\nwe adjust its value if it is too low before computation.\n\nThe formula is given by CIP 55,\nwith current value of `4310` for `coinsPerUTxOByte`.\n\nTODO: provide `coinsPerUTxOByte` in function arguments?\n\n","type":"Cardano.Utxo.Output -> Natural.Natural"},{"name":"minAdaForAssets","comment":" Compute minimum Ada lovelace for a given [MultiAsset] that would be sent to a given address.\n\nTODO: provide `coinsPerUTxOByte` in function arguments?\n\n","type":"Cardano.Address.Address -> Cardano.MultiAsset.MultiAsset Natural.Natural -> Natural.Natural"},{"name":"refAsString","comment":" Display the [OutputReference] as a String.\n","type":"Cardano.Utxo.OutputReference -> String.String"},{"name":"refDictFromList","comment":" Convenience function to create a `Dict` with [OutputReference] keys from a list.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"List.List ( Cardano.Utxo.OutputReference, a ) -> Cardano.Utxo.RefDict a"},{"name":"simpleOutput","comment":" Create a simple [Output] with just an [Address] and a [Value].\n","type":"Cardano.Address.Address -> Cardano.Value.Value -> Cardano.Utxo.Output"},{"name":"totalLovelace","comment":" Calculate the total number of lovelace in a collection of `Output`\n","type":"List.List Cardano.Utxo.Output -> Natural.Natural"}],"binops":[]},{"name":"Cardano.Value","comment":" Handling Cardano values.\n\n@docs Value, zero, onlyLovelace, onlyToken\n\n@docs add, addTokens, substract, atLeast, sum, normalize, compare\n\n@docs encode, fromCbor\n\n","unions":[],"aliases":[{"name":"Value","comment":" A multi-asset output Value. Contains tokens indexed by policy id and asset name.\n\nThis type maintains some invariants by construction.\nIn particular, a Value will never contain a zero quantity of a particular token.\n\nTODO: make sure the previous statement stays true by construction.\nThat would require an opaque type and some property tests.\n\n","args":[],"type":"{ lovelace : Natural.Natural, assets : Cardano.MultiAsset.MultiAsset Natural.Natural }"}],"values":[{"name":"add","comment":" Add the values of two UTxOs together.\n","type":"Cardano.Value.Value -> Cardano.Value.Value -> Cardano.Value.Value"},{"name":"addTokens","comment":" Add some tokens to another [Value].\n","type":"Cardano.MultiAsset.MultiAsset Natural.Natural -> Cardano.Value.Value -> Cardano.Value.Value"},{"name":"atLeast","comment":" Check that some value contains at least some minimum value.\n\n    onlyLovelace Natural.two\n      |> atLeast (onlyLovelace Natural.one)\n      --> True\n\n","type":"Cardano.Value.Value -> Cardano.Value.Value -> Basics.Bool"},{"name":"compare","comment":" Compare by amount of a given token.\n","type":"(Cardano.Value.Value -> Natural.Natural) -> Cardano.Value.Value -> Cardano.Value.Value -> Basics.Order"},{"name":"encode","comment":" CBOR encoder for [Value].\n","type":"Cardano.Value.Value -> Cbor.Encode.Encoder"},{"name":"fromCbor","comment":" CBOR decoder for [Value].\n","type":"Cbor.Decode.Decoder Cardano.Value.Value"},{"name":"normalize","comment":" Remove 0 amounts in non-ada assets.\n","type":"Cardano.Value.Value -> Cardano.Value.Value"},{"name":"onlyLovelace","comment":" Create a [Value] just containing Ada lovelaces.\n","type":"Natural.Natural -> Cardano.Value.Value"},{"name":"onlyToken","comment":" Create a [Value] just from some token amount.\n","type":"Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId -> Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName -> Natural.Natural -> Cardano.Value.Value"},{"name":"substract","comment":" Substract the second value from the first one: (v1 - v2).\n\nIt’s a saturating difference, so if the second value is bigger than the first,\nthe difference is clamped to 0.\n\nThe resulting [Value] is not normalized by default.\nSo the result may contain assets with 0 amounts.\nTo remove all 0 amount assets, call [normalize] on the substraction result.\n\n","type":"Cardano.Value.Value -> Cardano.Value.Value -> Cardano.Value.Value"},{"name":"sum","comment":" Sum the values of all tokens.\n","type":"List.List Cardano.Value.Value -> Cardano.Value.Value"},{"name":"zero","comment":" Empty [Value] with 0 ada and no token.\n","type":"Cardano.Value.Value"}],"binops":[]},{"name":"Cbor.Decode.Extra","comment":" Extra CBOR decoding utility functions.\n\n@docs set\n@docs natural, integer\n@docs failWith\n\n","unions":[],"aliases":[],"values":[{"name":"failWith","comment":" Helper decoder to display the raw bytes on which the decoder has failed.\n","type":"String.String -> Cbor.Decode.Decoder a"},{"name":"integer","comment":" Decode an unbounded integer.\n","type":"Cbor.Decode.Decoder Integer.Integer"},{"name":"natural","comment":" Decode an unbounded positive integer.\n","type":"Cbor.Decode.Decoder Natural.Natural"},{"name":"set","comment":" Decoder for a set of value. Either an array or within a tag 258.\n\nDon’t ask me why this exists. IOHK designed this standard long ago and wanted to use it.\nRegardless of what the people wanted.\n\nRef: <https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md>\n\n","type":"Cbor.Decode.Decoder a -> Cbor.Decode.Decoder (List.List a)"}],"binops":[]},{"name":"Cbor.Encode.Extra","comment":" Extra CBOR encoding utility functions.\n\n@docs natural, integer\n@docs nonEmptyField\n@docs associativeList, indefiniteList, beginBytes\n\n","unions":[],"aliases":[],"values":[{"name":"associativeList","comment":" Encode associative list with canonical ordering of the keys.\n\nThe keys in every map must be sorted lowest value to highest.\nSorting is performed on the bytes of the representation of the key\ndata items without paying attention to the 3/5 bit splitting for\nmajor types. (Note that this rule allows maps that have keys of\ndifferent types, even though that is probably a bad practice that\ncould lead to errors in some canonicalization implementations.)\nThe sorting rules are:\n\n  - If two keys have different lengths, the shorter one sorts\n    earlier;\n\n  - If two keys have the same length, the one with the lower value\n    in (byte-wise) lexical order sorts earlier.\n\n","type":"(k -> Cbor.Encode.Encoder) -> (v -> Cbor.Encode.Encoder) -> List.List ( k, v ) -> Cbor.Encode.Encoder"},{"name":"beginBytes","comment":" If you really need to build bytes with indefinite arrays.\n","type":"Cbor.Encode.Encoder"},{"name":"indefiniteList","comment":" If you really need indefinite lists.\n","type":"(a -> Cbor.Encode.Encoder) -> List.List a -> Cbor.Encode.Encoder"},{"name":"integer","comment":" Encode a large integer number.\n","type":"Integer.Integer -> Cbor.Encode.Encoder"},{"name":"natural","comment":" Encode a natural number.\n","type":"Natural.Natural -> Cbor.Encode.Encoder"},{"name":"nonEmptyField","comment":" Encode a foldable only if non empty.\n","type":"k -> (field -> Basics.Bool) -> (field -> Cbor.Encode.Encoder) -> (record -> field) -> Cbor.Encode.Step k record -> Cbor.Encode.Step k record"}],"binops":[]},{"name":"RationalNat","comment":" Unbounded positive rational numbers,\nbased on [Natural] numbers for the fraction.\n\n@docs RationalNat\n\n@docs zero, fromSafeInt\n\n@docs add, mul, floor\n\n","unions":[],"aliases":[{"name":"RationalNat","comment":" Unbounded positive rational numbers,\nbased on [Natural] numbers for both sides of the fraction.\n","args":[],"type":"{ num : Natural.Natural, denom : Natural.Natural }"}],"values":[{"name":"add","comment":" Addition\n\nRemark that the denominator part will grow due to exact computation.\nNot simplification is performed.\n\n","type":"RationalNat.RationalNat -> RationalNat.RationalNat -> RationalNat.RationalNat"},{"name":"floor","comment":" Return the integer part of that rational number.\n\nReturn [Nothing] if the denominator is 0.\n\n","type":"RationalNat.RationalNat -> Maybe.Maybe Natural.Natural"},{"name":"fromSafeInt","comment":" Convert from a safe JS integer (< 2^53) to [RationalNat],\nusing 1 for the denominator.\n\nThis has the same limitations than the [Natural] function with the same name.\n\n","type":"Basics.Int -> RationalNat.RationalNat"},{"name":"mul","comment":" Multiplication\n\nRemark that the denominator part will grow due to exact computation.\nNot simplification is performed.\n\n","type":"RationalNat.RationalNat -> RationalNat.RationalNat -> RationalNat.RationalNat"},{"name":"zero","comment":" 0\n","type":"RationalNat.RationalNat"}],"binops":[]},{"name":"Word7","comment":" Decoding 7-bits words.\n\n@docs fromBytes\n\n","unions":[],"aliases":[],"values":[{"name":"fromBytes","comment":" Decode a 7-bit encoded integer\n","type":"Bytes.Decode.Decoder Basics.Int"}],"binops":[]}]